import {
	IExecuteFunctions,
	INodeExecutionData,
	INodeType,
	INodeTypeDescription,
	NodeConnectionType,
	IDataObject,
} from 'n8n-workflow';

export class DataComparison implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'Data Comparison',
		name: 'dataComparison',
		icon: 'fa:exchange-alt',
		group: ['transform'],
		version: 1,
		description: 'Compare data between different databases using data-diff',
		defaults: {
			name: 'Data Comparison',
		},
		inputs: [NodeConnectionType.Main],
		outputs: [NodeConnectionType.Main],
		credentials: [
			{
				name: 'dataDiffConfig',
				required: true,
			},
		],
		properties: [
			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				options: [
					{
						name: 'Compare Table',
						value: 'compareTables',
						description: 'Compare two database tables',
						action: 'Compare two database tables',
					},
					{
						name: 'Compare Schema',
						value: 'compareSchemas',
						description: 'Compare database schemas',
						action: 'Compare database schemas',
					},
					{
						name: 'Get Comparison Result',
						value: 'getComparisonResult',
						description: 'Get the result of a previously started comparison',
						action: 'Get comparison result by ID',
					},
				],
				default: 'compareTables',
			},
			{
				displayName: 'Source Connection',
				name: 'sourceConnection',
				type: 'string',
				default: 'postgresql://metabase:metasample123@106.120.41.178:5436/sample',
				placeholder: 'postgresql://user:pass@host:port/db',
				description: '⚠️ 关于 "item 0/1" 选项：\n• 这些选项出现是因为上游有 Merge 节点\n• item 0 = 第一个数据库连接\n• item 1 = 第二个数据库连接\n• 但直接使用可能导致 undefined\n\n✅ 推荐的安全方法：\n1. 指定节点和索引：{{ $("NodeName").all()[0].json.connectionUrl }}\n2. 指定节点和索引：{{ $("NodeName").all()[1].json.connectionUrl }}\n3. 使用节点名：{{ $("PostgreSQL Connector").item.json.connectionUrl }}\n4. 使用节点名：{{ $("ClickZetta Connector").item.json.connectionUrl }}\n5. 当前输入索引：{{ $input.all()[0].json.connectionUrl }}\n6. 启用"自动填充"选项\n7. 使用下方的默认连接字符串\n\n💡 示例：{{ $("CZ Database Connector Test").all()[0].json.connectionUrl }}',
				typeOptions: {
					rows: 3,
				},
				displayOptions: {
					show: {
						operation: ['compareTables', 'compareSchemas'],
					},
				},
				required: false,
			},
			{
				displayName: 'Target Connection',
				name: 'targetConnection',
				type: 'string',
				default: 'clickzetta://qiliang:Ql123456!@jnsxwfyr.uat-api.clickzetta.com/quick_start?virtualcluster=default_ap&schema=from_pg',
				placeholder: 'clickzetta://user:pass@host:port/db',
				description: '⚠️ 关于 "item 0/1" 选项：\n• 这些选项出现是因为上游有 Merge 节点\n• item 0 = 第一个数据库连接\n• item 1 = 第二个数据库连接\n• 但直接使用可能导致 undefined\n\n✅ 推荐的安全方法：\n1. 指定节点和索引：{{ $("NodeName").all()[0].json.connectionUrl }}\n2. 指定节点和索引：{{ $("NodeName").all()[1].json.connectionUrl }}\n3. 使用节点名：{{ $("PostgreSQL Connector").item.json.connectionUrl }}\n4. 使用节点名：{{ $("ClickZetta Connector").item.json.connectionUrl }}\n5. 当前输入索引：{{ $input.all()[1].json.connectionUrl }}\n6. 启用"自动填充"选项\n7. 使用下方的默认连接字符串\n\n💡 示例：{{ $("CZ Database Connector Test").all()[1].json.connectionUrl }}',
				typeOptions: {
					rows: 2,
				},
				displayOptions: {
					show: {
						operation: ['compareTables', 'compareSchemas'],
					},
				},
				required: false,
			},
			{
				displayName: 'Source Table',
				name: 'sourceTable',
				type: 'string',
				default: 'invoices',
				placeholder: 'schema.table_name or {{ $("List Tables Node").item.json.tables[0].name }}',
				description: 'Source table name. Leave empty for auto-detection from upstream PostgreSQL/Database Connector nodes. Use expressions like {{ $("NodeName").item.json.tables[0].name }} for specific nodes.',
				displayOptions: {
					show: {
						operation: ['compareTables'],
					},
				},
				required: false,
			},
			{
				displayName: 'Target Table',
				name: 'targetTable',
				type: 'string',
				default: 'invoices',
				placeholder: 'schema.table_name or {{ $("List Tables Node").item.json.data[0].name }}',
				description: 'Target table name. Leave empty for auto-detection from upstream ClickZetta Connector nodes. Use expressions like {{ $("NodeName").item.json.data[0].name }} for specific nodes.',
				displayOptions: {
					show: {
						operation: ['compareTables'],
					},
				},
				required: false,
			},
			{
				displayName: 'Key Columns',
				name: 'keyColumns',
				type: 'string',
				default: 'id',
				placeholder: 'id,user_id (leave empty to use credential default)',
				description: 'Primary key columns (comma-separated). Leave empty to use the default from credentials.',
				displayOptions: {
					show: {
						operation: ['compareTables'],
					},
				},
			},
			{
				displayName: 'Columns to Compare',
				name: 'columnsToCompare',
				type: 'string',
				default: '',
				placeholder: 'name,email,status (leave empty for all columns)',
				description: 'Specific columns to compare (comma-separated, leave empty to compare all columns except excluded ones)',
				displayOptions: {
					show: {
						operation: ['compareTables'],
					},
				},
			},
			{
				displayName: 'Where Condition',
				name: 'whereCondition',
				type: 'string',
				default: '',
				placeholder: 'status = \'active\' AND created_date > \'2023-01-01\'',
				description: 'SQL WHERE condition to filter rows (optional, specific to this comparison)',
				displayOptions: {
					show: {
						operation: ['compareTables'],
					},
				},
			},
			{
				displayName: 'Auto-fill from upstream',
				name: 'autoFillFromUpstream',
				type: 'boolean',
				default: true,
				description: 'Automatically fill connection URLs and table lists from upstream DatabaseConnector/ClickzettaConnector nodes',
			},
			{
				displayName: 'Comparison ID',
				name: 'comparisonId',
				type: 'string',
				default: '',
				placeholder: 'e.g., 02f29186-e0c9-464c-8e7e-7ec66ac7c24d',
				description: 'The ID of the comparison task to get results for. Use "item 0" for first input, "item 1" for second input, or drag the comparisonId field from previous Compare Tables operation.',
				displayOptions: {
					show: {
						operation: ['getComparisonResult'],
					},
				},
				required: true,
				typeOptions: {
					alwaysOpenEditWindow: false,
					rows: 1,
				},
			},
		],
	};

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const items = this.getInputData();
		const returnData: INodeExecutionData[] = [];
		const operation = this.getNodeParameter('operation', 0) as string;
		const autoFillFromUpstream = this.getNodeParameter('autoFillFromUpstream', 0) as boolean;

		for (let i = 0; i < items.length; i++) {
			try {
				let result: any = {};

				// 尝试从上游节点获取连接信息
				const upstreamData = DataComparison.extractUpstreamData(items, autoFillFromUpstream);

				switch (operation) {
					case 'compareTables':
						result = await DataComparison.compareTables(this, i, upstreamData);
						break;
					case 'compareSchemas':
						result = await DataComparison.compareSchemas(this, i, upstreamData);
						break;
					case 'getComparisonResult':
						result = await DataComparison.getComparisonResult(this, i);
						break;
					default:
						throw new Error(`Unknown operation: ${operation}`);
				}

				returnData.push({
					json: {
						operation,
						success: true,
						upstreamData: upstreamData,
						data: result,
						timestamp: new Date().toISOString(),
					},
				});
			} catch (error: any) {
				console.error('DataComparison执行错误:', error);
				console.error('错误堆栈:', error.stack);

				// 收集调试信息
				const debugInfo: any = {
					operation,
					itemIndex: i,
					autoFillFromUpstream,
					inputItemsCount: items.length,
					error: error?.message || 'Unknown error',
					errorStack: error?.stack || 'No stack trace available',
					timestamp: new Date().toISOString(),
				};

				// 安全地添加上游数据信息
				try {
					const upstreamData = DataComparison.extractUpstreamData(items, autoFillFromUpstream);
					debugInfo.upstreamData = {
						connectionsCount: upstreamData?.connections?.length || 0,
						tablesCount: upstreamData?.tables?.length || 0,
						connections: upstreamData?.connections || [],
						tables: upstreamData?.tables || []
					};
				} catch (extractError) {
					debugInfo.upstreamDataError = extractError?.message || 'Failed to extract upstream data';
				}

				// 尝试获取节点参数
				try {
					debugInfo.nodeParameters = {
						sourceConnection: this.getNodeParameter('sourceConnection', i, ''),
						targetConnection: this.getNodeParameter('targetConnection', i, ''),
						sourceTable: this.getNodeParameter('sourceTable', i, ''),
						targetTable: this.getNodeParameter('targetTable', i, ''),
					};
				} catch (paramError) {
					debugInfo.nodeParametersError = paramError?.message || 'Failed to get node parameters';
				}

				// 分析错误类型并提供改进建议
				let errorCategory = 'unknown';
				let improvementSuggestions: string[] = [];

				if (error.message.includes('connection already closed')) {
					errorCategory = 'database_connection_closed';
					improvementSuggestions = [
						'🔄 立即重试：这通常是临时的连接问题',
						'🔧 检查数据库服务器负载和连接池配置',
						'⏰ 验证数据库连接超时设置（通常需要 > 30秒）',
						'🌐 确认网络连接稳定性（特别是跨网络环境）',
						'📊 检查数据库服务器是否有连接数限制',
						'🔍 查看数据库日志以了解连接关闭原因',
						'⚙️ 考虑在data-diff API中增加连接重试机制',
						'🏥 检查数据库服务器健康状况和内存使用情况'
					];
				} else if (error.message.includes('timeout')) {
					errorCategory = 'timeout';
					improvementSuggestions = [
						'检查网络连接速度',
						'验证数据库服务器负载',
						'考虑分批处理大量数据',
						'检查防火墙设置',
						'确认API服务状态'
					];
				} else if (error.message.includes('authentication') || error.message.includes('认证')) {
					errorCategory = 'authentication';
					improvementSuggestions = [
						'检查数据库用户名和密码',
						'验证数据库用户权限',
						'确认数据库允许远程连接',
						'检查证书和SSL配置'
					];
				} else if (error.message.includes('not found') || error.message.includes('不存在')) {
					errorCategory = 'resource_not_found';
					improvementSuggestions = [
						'检查数据库名称是否正确',
						'验证表名和schema名称',
						'确认数据库用户有访问权限',
						'检查大小写敏感性'
					];
				} else if (error.message.includes('ECONNREFUSED') || error.message.includes('连接失败')) {
					errorCategory = 'connection_refused';
					improvementSuggestions = [
						'检查API服务是否运行',
						'验证Docker容器状态',
						'检查端口是否被占用',
						'确认网络配置正确'
					];
				}

				debugInfo.errorAnalysis = {
					category: errorCategory,
					suggestions: improvementSuggestions
				};

				returnData.push({
					json: {
						operation,
						success: false,
						error: error?.message || 'Unknown error',
						errorCategory,
						improvementSuggestions,
						debugInfo,
						timestamp: new Date().toISOString(),
					},
				});
			}
		}

		return [returnData];
	}

	private static async compareTables(context: IExecuteFunctions, itemIndex: number, upstreamData: any): Promise<any> {
		let sourceConnection = context.getNodeParameter('sourceConnection', itemIndex) as string;
		let targetConnection = context.getNodeParameter('targetConnection', itemIndex) as string;
		let sourceTable = context.getNodeParameter('sourceTable', itemIndex) as string;
		let targetTable = context.getNodeParameter('targetTable', itemIndex) as string;
		const keyColumns = context.getNodeParameter('keyColumns', itemIndex) as string;
		const columnsToCompare = context.getNodeParameter('columnsToCompare', itemIndex) as string;
		const whereCondition = context.getNodeParameter('whereCondition', itemIndex) as string;

		// 获取凭证
		const credentials = await context.getCredentials('dataDiffConfig');

		// 获取所有输入项以便处理 item 0/1 的情况
		const allItems = context.getInputData();

		// 检查连接字符串是否为空或 undefined，使用凭证中的默认值
		if (!sourceConnection || sourceConnection === 'undefined') {
			sourceConnection = (credentials?.defaultSourceConnection as string) || '';
			console.log('使用凭证中的默认源连接');
		}
		if (!targetConnection || targetConnection === 'undefined') {
			targetConnection = (credentials?.defaultTargetConnection as string) || '';
			console.log('使用凭证中的默认目标连接');
		}

		// 如果表名为空，尝试从上游数据获取
		if (!sourceTable && upstreamData.tables && upstreamData.tables.length > 0) {
			// 选择第一个非系统表
			const filteredTables = upstreamData.tables.filter((table: any) => {
				const name = table?.name || table?.value || table;
				return !name.startsWith('_') && !name.includes('metadata') && !name.includes('system');
			});
			sourceTable = filteredTables.length > 0 ?
				(filteredTables[0].name || filteredTables[0].value || filteredTables[0]) :
				(upstreamData.tables[0].name || upstreamData.tables[0].value || upstreamData.tables[0]);
		}

		if (!targetTable && upstreamData.tables && upstreamData.tables.length > 0) {
			// 选择第一个非系统表，但与源表不同
			const filteredTables = upstreamData.tables.filter((table: any) => {
				const name = table?.name || table?.value || table;
				return !name.startsWith('_') && !name.includes('metadata') && !name.includes('system') && name !== sourceTable;
			});
			if (filteredTables.length > 0) {
				targetTable = filteredTables[0].name || filteredTables[0].value || filteredTables[0];
			} else if (upstreamData.tables.length > 1) {
				// 如果没有合适的过滤表，选择第二个表
				targetTable = upstreamData.tables[1].name || upstreamData.tables[1].value || upstreamData.tables[1];
			} else {
				// 如果只有一个表，使用相同的表（可能是不同数据库的同名表）
				targetTable = sourceTable;
			}
		}

		console.log('连接和表信息:', {
			sourceConnection: sourceConnection ? 'present' : 'missing',
			targetConnection: targetConnection ? 'present' : 'missing',
			sourceTable: sourceTable || 'missing',
			targetTable: targetTable || 'missing',
			availableTables: upstreamData.tables?.length || 0
		});

		if (!sourceConnection) {
			throw new Error('Source connection string is required. Please:\n1. Provide it in the node parameters\n2. Set defaultSourceConnection in credentials\n3. Use drag-and-drop from upstream nodes\n4. Check if your expression (e.g., "{{ $json.connectionUrl }}") returns undefined - verify the upstream node name and field path');
		}
		if (!targetConnection) {
			throw new Error('Target connection string is required. Please:\n1. Provide it in the node parameters\n2. Set defaultTargetConnection in credentials\n3. Use drag-and-drop from upstream nodes\n4. Check if your expression (e.g., "{{ $json.connectionUrl }}") returns undefined - verify the upstream node name and field path');
		}
		if (!sourceTable) {
			throw new Error('Source table name is required');
		}
		if (!targetTable) {
			throw new Error('Target table name is required');
		}

		// 参数优先级：节点表单参数 > 凭据配置 > 默认值
		const mergedKeyColumns = keyColumns || (typeof credentials?.keyColumns === 'string' ? credentials.keyColumns : '') || 'id';
		const mergedSampleSize = (typeof credentials?.sampleSize === 'number' ? credentials.sampleSize : 0) || 10000;
		const mergedThreads = (typeof credentials?.threads === 'number' ? credentials.threads : 0) || 4;
		const mergedCaseSensitive = credentials?.caseSensitive !== undefined ? credentials.caseSensitive : true;
		const mergedTolerance = (typeof credentials?.tolerance === 'number' ? credentials.tolerance : 0) || 0.001;
		const mergedMethod = (typeof credentials?.method === 'string' ? credentials.method : '') || 'hashdiff';
		const mergedExcludeColumns = (typeof credentials?.excludeColumns === 'string' ? credentials.excludeColumns : '') || '';
		const mergedBisectionThreshold = (typeof credentials?.bisectionThreshold === 'number' ? credentials.bisectionThreshold : 0) || 1024;
		const mergedStrictTypeChecking = credentials?.strictTypeChecking !== undefined ? credentials.strictTypeChecking : false;

		// 调用API
		try {
			const apiUrl = 'http://data-diff-api:8000/api/v1/compare/tables/nested';

			// 解析列名 - 使用合并后的参数，确保类型安全
			const keyColumnsList = typeof mergedKeyColumns === 'string' && mergedKeyColumns ?
				mergedKeyColumns.split(',').map(col => col.trim()).filter(col => col) :
				['id'];

			const columnsToCompareList = typeof columnsToCompare === 'string' && columnsToCompare ?
				columnsToCompare.split(',').map(col => col.trim()).filter(col => col) :
				[];

			// 处理排除列（来自凭据），确保类型安全
			const excludeColumnsList = typeof mergedExcludeColumns === 'string' && mergedExcludeColumns ?
				mergedExcludeColumns.split(',').map(col => col.trim()).filter(col => col) :
				[];

			// 解析连接字符串为配置对象
			const sourceConfig = DataComparison.parseConnectionString(sourceConnection);
			const targetConfig = DataComparison.parseConnectionString(targetConnection);

			// 使用嵌套的 JSON 请求方式，与 nested 端点保持一致
			const requestData = {
				source_config: sourceConfig,
				target_config: targetConfig,
				comparison_config: {
					source_table: sourceTable,
					target_table: targetTable,
					key_columns: keyColumnsList,
					columns_to_compare: columnsToCompareList.length > 0 ? columnsToCompareList : undefined,
					exclude_columns: excludeColumnsList.length > 0 ? excludeColumnsList : undefined,
					sample_size: mergedSampleSize,
					threads: mergedThreads,
					case_sensitive: mergedCaseSensitive,
					tolerance: mergedTolerance,
					algorithm: mergedMethod,
					bisection_threshold: mergedBisectionThreshold,
					where_condition: whereCondition || undefined,
					strict_type_checking: mergedStrictTypeChecking
				}
			};

			console.log('发送API请求 (纯JSON方式)');
			console.log('请求URL:', apiUrl);
			console.log('请求体:', JSON.stringify(requestData, null, 2));

			// 发送请求（使用重试机制）
			try {
				const response = await DataComparison.apiCallWithRetry(
					context,
					'POST',
					'/compare/data',
					requestData,
					3,
					2000
				);

				console.log('API请求成功，响应:', JSON.stringify(response));

				// 检查 API 是否返回错误
				if (response.error) {
					throw new Error(`API返回错误: ${response.error}`);
				}

				// API 返回的是 comparison_id，直接返回而不等待结果
				const comparisonId = response.comparison_id;
				if (!comparisonId) {
					throw new Error('API 未返回比对ID');
				}

				return {
					comparisonId: comparisonId,
					status: response.body.status || 'started',
					message: response.body.message || '表比对任务已启动',
					requestData: requestData,
					apiUrl: apiUrl,
					timestamp: new Date().toISOString(),
					retrieveResultUrl: `http://data-diff-api:8000/api/v1/compare/results/${comparisonId}`,
					note: 'Use the "Get Comparison Result" operation with this comparison ID to retrieve the results'
				};
			} catch (error: any) {
				console.error('API请求失败:', error.message);
				if (error.response) {
					console.error('错误响应状态:', error.response.statusCode);
					console.error('错误响应内容:', JSON.stringify(error.response.body));
				}
				throw new Error(`启动表比对失败: ${error.message}`);
			}
		} catch (error: any) {
			throw new Error(`Data comparison API request failed: ${error.message}`);
		}
	}

	private static async compareSchemas(context: IExecuteFunctions, itemIndex: number, upstreamData: any): Promise<any> {
		let sourceConnection = context.getNodeParameter('sourceConnection', itemIndex) as string;
		let targetConnection = context.getNodeParameter('targetConnection', itemIndex) as string;

		// 智能收集所有可用的连接信息
		const allItems = context.getInputData();
		const allConnections: string[] = [];

		// 从所有输入项中收集连接信息
		for (let i = 0; i < allItems.length; i++) {
			const item = allItems[i];
			if (item.json) {
				const connectionFields = ['connectionUrl', 'connectionString', 'connection', 'url'];
				for (const field of connectionFields) {
					if (item.json[field] && typeof item.json[field] === 'string') {
						if (!allConnections.includes(item.json[field])) {
							allConnections.push(item.json[field]);
						}
					}
				}
			}
		}

		// 从节点参数中收集连接信息
		for (let i = 0; i < allItems.length; i++) {
			try {
				const srcConn = context.getNodeParameter('sourceConnection', i, '') as string;
				const tgtConn = context.getNodeParameter('targetConnection', i, '') as string;

				if (srcConn && !allConnections.includes(srcConn)) {
					allConnections.push(srcConn);
				}
				if (tgtConn && !allConnections.includes(tgtConn)) {
					allConnections.push(tgtConn);
				}
			} catch (error) {
				// 忽略参数获取错误，继续处理其他项
			}
		}

		// 从上游数据中收集连接信息
		if (upstreamData.connections && upstreamData.connections.length > 0) {
			for (const conn of upstreamData.connections) {
				if (conn.url && !allConnections.includes(conn.url)) {
					allConnections.push(conn.url);
				}
			}
		}

		// 智能分配连接信息
		if (!sourceConnection && allConnections.length > 0) {
			sourceConnection = allConnections[0];
		}
		if (!targetConnection && allConnections.length > 1) {
			targetConnection = allConnections[1];
		} else if (!targetConnection && allConnections.length > 0) {
			targetConnection = allConnections[0];
		}

		console.log('模式比较智能收集结果:', {
			itemIndex,
			allConnections: allConnections.map(c => c.substring(0, 20) + '...'),
			sourceConnection: sourceConnection ? 'present' : 'missing',
			targetConnection: targetConnection ? 'present' : 'missing',
			inputItemsCount: allItems.length
		});

		if (!sourceConnection) {
			throw new Error('Source connection string is required');
		}
		if (!targetConnection) {
			throw new Error('Target connection string is required');
		}

		// 调用API - 使用嵌套端点
		try {
			const apiUrl = 'http://data-diff-api:8000/api/v1/compare/schemas/nested';

			// 解析连接字符串为配置对象
			const sourceConfig = DataComparison.parseConnectionString(sourceConnection);
			const targetConfig = DataComparison.parseConnectionString(targetConnection);

			// 使用嵌套的 JSON 请求方式
			const requestData = {
				source_config: sourceConfig,
				target_config: targetConfig
			};
		console.log('发送模式比对API请求 (嵌套JSON方式)');
		console.log('请求URL:', apiUrl);
		console.log('请求体:', JSON.stringify(requestData, null, 2));
		
		// 添加连接诊断信息
		console.log('=== 连接诊断信息 ===');
		console.log('源数据库连接:', {
			type: sourceConfig.type,
			host: sourceConfig.host,
			port: sourceConfig.port,
			database: sourceConfig.database,
			hasCredentials: !!(sourceConfig.username && sourceConfig.password)
		});
		console.log('目标数据库连接:', {
			type: targetConfig.type,
			host: targetConfig.host,
			port: targetConfig.port,
			database: targetConfig.database,
			hasCredentials: !!(targetConfig.username && targetConfig.password)
		});
		console.log('========================');

		// 预先测试数据库连接（可选，用于更好的错误诊断）
		try {
			console.log('正在测试源数据库连接...');
			const sourceTest = await DataComparison.testDatabaseConnection(context, sourceConfig);
			console.log('源数据库连接测试结果:', sourceTest);
			
			console.log('正在测试目标数据库连接...');
			const targetTest = await DataComparison.testDatabaseConnection(context, targetConfig);
			console.log('目标数据库连接测试结果:', targetTest);
			
			// 如果连接测试失败，提供详细的错误信息
			if (!sourceTest.success || !targetTest.success) {
				let errorMsg = '数据库连接测试失败:\n';
				if (!sourceTest.success) {
					errorMsg += `源数据库连接失败: ${sourceTest.error}\n`;
				}
				if (!targetTest.success) {
					errorMsg += `目标数据库连接失败: ${targetTest.error}\n`;
				}
				errorMsg += '\n请检查数据库连接配置、网络连接和数据库服务状态。';
				console.warn(errorMsg);
				// 注意：这里只是警告，不抛出异常，因为API可能有不同的连接测试端点
			}
		} catch (connectionTestError: any) {
			console.warn('连接测试失败（将继续尝试比对）:', connectionTestError.message);
		}

			try {
				const response = await DataComparison.apiCallWithRetry(
					context,
					'POST',
					'/compare/schema',
					requestData,
					3,
					2000
				);

				console.log('模式比对API响应:', JSON.stringify(response));

				// 检查 API 是否返回错误
				if (response.error) {
					throw new Error(`API返回错误: ${response.error}`);
				}

				// 格式化返回结果
				const result = response.result;
				const summary = result.summary || {};
				const diff = result.diff || {};

				// 生成详细的差异明细
				const detailedDifferences = DataComparison.generateDetailedDifferences(diff);
				const executionSummary = DataComparison.generateSchemaSummary(summary, diff);

				return {
					status: response.body.status || 'completed',
					sourceType: response.body.source_type,
					targetType: response.body.target_type,
					summary: {
						identical: summary.schemas_identical || false,
						totalDifferences: summary.total_differences || 0,
						tableDifferences: summary.table_differences || 0,
						columnDifferences: summary.column_differences || 0,
						typeDifferences: summary.type_differences || 0
					},
					differences: {
						tablesOnlyInSource: diff.tables_only_in_source || [],
						tablesOnlyInTarget: diff.tables_only_in_target || [],
						commonTables: diff.common_tables || [],
						columnDifferences: diff.column_diffs || {},
						typeDifferences: diff.type_diffs || {}
					},
					// 添加详细的差异明细
					detailedDifferences: detailedDifferences,
					sourceSchema: {
						databaseType: result.source_schema?.database_type,
						schemaName: result.source_schema?.schema_name,
						totalTables: result.source_schema?.tables?.length || 0,
						tables: result.source_schema?.tables || []
					},
					targetSchema: {
						databaseType: result.target_schema?.database_type,
						schemaName: result.target_schema?.schema_name,
						totalTables: result.target_schema?.tables?.length || 0,
						tables: result.target_schema?.tables || []
					},
					// 执行摘要（友好的文本描述）
					executionSummary: executionSummary,
					requestData: requestData,
					apiUrl: apiUrl,
					timestamp: result.timestamp || new Date().toISOString(),
					// 正确使用executionTime字段
					executionTime: '模式比对已完成',
					// 添加处理时间信息
					processedAt: new Date().toISOString(),
					duration: 'instant' // 模式比对通常很快
				};		} catch (error: any) {
			console.error('模式比对API请求失败:', error.message);
			console.error('错误详情:', error);
			
			// 详细的错误分析和处理
			let errorMessage = '模式比对失败';
			let errorDetails = '';
			
			if (error.response) {
				console.error('错误响应状态:', error.response.statusCode);
				console.error('错误响应内容:', JSON.stringify(error.response.body));
				
				if (error.response.body && error.response.body.error) {
					errorDetails = error.response.body.error;
					
					// 针对常见的数据库连接错误提供更好的错误信息
					if (errorDetails.includes('connection already closed')) {
						errorMessage = '数据库连接已关闭';
						errorDetails = '数据库连接在比对过程中被意外关闭。这可能是因为：\n' +
							'1. 数据库连接超时\n' +
							'2. 数据库服务器重启或不可访问\n' +
							'3. 网络连接中断\n' +
							'4. 数据库连接池配置问题\n' +
							'请检查数据库连接配置并重试。';
					} else if (errorDetails.includes('timeout')) {
						errorMessage = '数据库连接超时';
						errorDetails = '数据库连接超时。请检查：\n' +
							'1. 数据库服务器是否正常运行\n' +
							'2. 网络连接是否稳定\n' +
							'3. 数据库负载是否过高\n' +
							'4. 连接配置是否正确';
					} else if (errorDetails.includes('authentication')) {
						errorMessage = '数据库认证失败';
						errorDetails = '数据库认证失败。请检查：\n' +
							'1. 用户名和密码是否正确\n' +
							'2. 数据库用户是否有足够的权限\n' +
							'3. 数据库是否允许远程连接';
					} else if (errorDetails.includes('does not exist') || errorDetails.includes('not found')) {
						errorMessage = '数据库或表不存在';
						errorDetails = '指定的数据库、schema或表不存在。请检查：\n' +
							'1. 数据库名称是否正确\n' +
							'2. Schema名称是否正确\n' +
							'3. 表名称是否正确\n' +
							'4. 数据库用户是否有访问权限';
					}
				}
			} else if (error.message.includes('ECONNREFUSED')) {
				errorMessage = 'API服务连接失败';
				errorDetails = 'data-diff API服务无法连接。请检查：\n' +
					'1. API服务是否正在运行\n' +
					'2. Docker容器是否正常启动\n' +
					'3. 网络配置是否正确';
			} else if (error.message.includes('ETIMEDOUT')) {
				errorMessage = 'API请求超时';
				errorDetails = 'API请求超时。请检查：\n' +
					'1. 网络连接是否稳定\n' +
					'2. API服务是否响应正常\n' +
					'3. 数据量是否过大导致处理时间过长';
			}
			
			// 构建友好的错误消息
			const friendlyError = errorDetails ? 
				`${errorMessage}: ${errorDetails}` : 
				`${errorMessage}: ${error.message}`;
			
			throw new Error(friendlyError);
		}
		} catch (error: any) {
			throw new Error(`Schema comparison API request failed: ${error.message}`);
		}
	}

	private static async getComparisonResult(context: IExecuteFunctions, itemIndex: number): Promise<any> {
		const comparisonId = context.getNodeParameter('comparisonId', itemIndex) as string;

		if (!comparisonId) {
			throw new Error('Comparison ID is required');
		}

		// 调用 API 获取比对结果（使用重试机制）
		try {
			const response = await DataComparison.apiCallWithRetry(
				context,
				'GET',
				`/compare/results/${comparisonId}`,
				null,
				3,
				2000
			);

			// 检查响应是否有效
			if (!response) {
				throw new Error(`Empty response for comparison ID: ${comparisonId}`);
			}

			return {
				comparisonId,
				resultUrl: `http://data-diff-api:8000/api/v1/compare/results/${comparisonId}`,
				status: 'completed',
				data: response,
				retrievedAt: new Date().toISOString(),
			};
		} catch (error: any) {
			console.error('获取比对结果失败:', error.message);
			console.error('错误详情:', error);
			
			// 详细的错误分析和处理
			let errorMessage = '获取比对结果失败';
			let errorDetails = '';
			
			if (error.message.includes('ECONNREFUSED') || error.message.includes('connect')) {
				errorMessage = 'API服务连接失败';
				errorDetails = `无法连接到 data-diff API 服务 (http://data-diff-api:8000)。请检查：\n` +
					'1. API 服务是否正在运行\n' +
					'2. Docker 容器是否正常启动\n' +
					'3. 网络配置是否正确\n' +
					'4. 防火墙是否阻止了连接';
			} else if (error.message.includes('timeout')) {
				errorMessage = '获取结果超时';
				errorDetails = '获取比对结果超时。请检查：\n' +
					'1. 网络连接是否稳定\n' +
					'2. API 服务是否响应正常\n' +
					'3. 比对任务是否仍在运行中';
			} else if (error.message.includes('404') || error.message.includes('not found')) {
				errorMessage = '比对结果不存在';
				errorDetails = `比对ID "${comparisonId}" 对应的结果不存在。可能的原因：\n` +
					'1. 比对任务仍在运行中，请稍后重试\n' +
					'2. 比对ID 不正确\n' +
					'3. 比对任务已过期或被清理\n' +
					'4. 比对任务执行失败';
			} else if (error.response) {
				const statusCode = error.response.statusCode || 'unknown';
				const statusMessage = error.response.statusMessage || 'unknown';
				
				errorMessage = `HTTP错误 ${statusCode}`;
				errorDetails = `API 返回错误状态：${statusCode} ${statusMessage}`;
				
				if (error.response.body) {
					try {
						const body = typeof error.response.body === 'string' ? 
							JSON.parse(error.response.body) : error.response.body;
						if (body.error) {
							errorDetails += `\n错误详情：${body.error}`;
						}
					} catch (parseError) {
						errorDetails += `\n响应内容：${error.response.body}`;
					}
				}
			}
			
			// 构建友好的错误消息
			const friendlyError = errorDetails ? 
				`${errorMessage}\n\n${errorDetails}` : 
				`${errorMessage}: ${error.message}`;
			
			throw new Error(friendlyError);
		}
	}

	private static extractUpstreamData(items: INodeExecutionData[], autoFill: boolean): any {
		// 始终返回一个带有默认结构的对象，避免 undefined 错误
		const upstreamData: any = {
			connections: [],
			tables: [],
			isMergedData: false, // 标记是否来自 Merge 节点
			sourceInfo: {}, // 记录数据来源信息
		};

		console.log('=== extractUpstreamData 开始 ===');
		console.log('autoFill:', autoFill);
		console.log('items数量:', items.length);
		console.log('原始items数据:', JSON.stringify(items, null, 2));

		if (!autoFill || items.length === 0) {
			console.log('autoFill为false或没有输入数据，返回空结构');
			return upstreamData;
		}

		// 检测是否来自 Merge 节点（多个items且结构相似）
		if (items.length > 1) {
			const hasConnectionFields = items.every(item => {
				if (!item.json) return false;
				const connectionFields = ['connectionUrl', 'connectionString', 'connection', 'url'];
				return connectionFields.some(field => item.json[field]);
			});

			if (hasConnectionFields) {
				upstreamData.isMergedData = true;
				console.log('⚠️ 检测到来自 Merge 节点的数据，包含多个连接');
				upstreamData.sourceInfo.mergeDetected = true;
				upstreamData.sourceInfo.mergeItemCount = items.length;
			}
		}

		// 从上游节点提取连接信息和表列表
		for (const item of items) {
			if (item.json) {
				console.log('处理item.json:', JSON.stringify(item.json, null, 2));

				// 提取连接 URL - 支持多种字段名和格式
				const connectionFields = [
					'connectionUrl', 'connectionString', 'connection',
					'url', 'database_url', 'db_url', 'conn_str'
				];

				for (const field of connectionFields) {
					if (item.json[field]) {
						console.log(`找到连接字段 ${field}:`, item.json[field]);

						// 智能检测数据库类型 - 支持多种字段来源
						let dbType = item.json.databaseType || item.json.database_type;
						console.log('初始dbType:', dbType);

						// 如果没有顶级 databaseType 字段，尝试从 connectionConfig 中获取
						if (!dbType || dbType === 'undefined') {
							const connectionConfig = item.json.connectionConfig || item.json.config;
							console.log('检查connectionConfig:', connectionConfig);

							if (connectionConfig && typeof connectionConfig === 'object' && 'type' in connectionConfig) {
								const configType = (connectionConfig as any).type;
								console.log('从connectionConfig获得type:', configType);

								// 统一数据库类型命名
								if (configType === 'clickzetta') {
									dbType = 'clickzetta';
								} else if (configType === 'postgres' || configType === 'postgresql') {
									dbType = 'postgresql';
								} else if (configType === 'mysql') {
									dbType = 'mysql';
								} else if (configType === 'sqlite') {
									dbType = 'sqlite';
								} else {
									dbType = configType;
								}
								console.log('映射后的dbType:', dbType);
							}
						}

						// 如果还是没有明确的数据库类型，尝试从连接字符串推断
						if (!dbType || dbType === 'undefined') {
							const connectionUrl = item.json[field] as string;
							console.log('从连接字符串推断类型:', connectionUrl);

							if (connectionUrl.startsWith('postgresql://')) {
								dbType = 'postgresql';
							} else if (connectionUrl.startsWith('clickzetta://')) {
								dbType = 'clickzetta';
							} else if (connectionUrl.startsWith('mysql://')) {
								dbType = 'mysql';
							} else if (connectionUrl.startsWith('sqlite://')) {
								dbType = 'sqlite';
							} else {
								dbType = 'unknown';
							}
							console.log('推断得到的dbType:', dbType);
						}

						// 统一 postgres 为 postgresql
						if (dbType === 'postgres') {
							dbType = 'postgresql';
						}

						const connectionData = {
							url: item.json[field],
							type: dbType,
							databaseType: dbType, // 添加标准的 databaseType 字段
							config: item.json.connectionConfig || item.json.config,
							source: field, // 记录来源字段名
						};

						console.log('添加连接数据:', connectionData);
						upstreamData.connections.push(connectionData);
					}
				}

				// 特殊处理：如果是 ClickZetta 连接器的格式
				if (item.json.instance && item.json.username && item.json.password) {
					// 构建 ClickZetta 连接字符串
					const clickzettaUrl = `clickzetta://${item.json.username}:${item.json.password}@${item.json.instance}.${item.json.service || 'uat-api.clickzetta.com'}/${item.json.database || 'default'}?virtualcluster=${item.json.virtualcluster || 'default_ap'}&schema=${item.json.schema || 'public'}`;
					upstreamData.connections.push({
						url: clickzettaUrl,
						type: 'clickzetta',
						config: item.json,
						source: 'clickzetta_config',
					});
				}

				// 特殊处理：如果是 PostgreSQL 连接器的格式
				if (item.json.host && item.json.database && item.json.username && item.json.password) {
					// 构建 PostgreSQL 连接字符串
					const pgUrl = `postgresql://${item.json.username}:${item.json.password}@${item.json.host}:${item.json.port || 5432}/${item.json.database}`;
					upstreamData.connections.push({
						url: pgUrl,
						type: 'postgresql',
						config: item.json,
						source: 'postgresql_config',
					});
				}

				// 提取表列表 - 支持多种格式
				if (item.json.tables && Array.isArray(item.json.tables)) {
					const processedTables = item.json.tables.map((table: any) => {
						if (typeof table === 'string') {
							return {
								name: table,
								value: table,
								description: `Table: ${table}`
							};
						} else if (table && typeof table === 'object') {
							// 安全地处理对象格式
							const tableName = table.name || table.value || table.table_name;
							if (tableName && typeof tableName === 'string') {
								return {
									name: tableName,
									value: table.value || tableName,
									description: table.description || `Table: ${tableName}`
								};
							} else {
								// 如果无法提取有效的表名，跳过这个条目
								console.warn('无法提取有效的表名:', table);
								return null;
							}
						}
						return table;
					}).filter(table => table !== null); // 过滤掉无效的表

					upstreamData.tables = upstreamData.tables.concat(processedTables);
				}

				// 支持 data 字段中的表列表（某些节点使用这种格式）
				if (item.json.data && Array.isArray(item.json.data)) {
					// 检查是否是表名数组
					const dataAsTableList = item.json.data.map((dataItem: any) => {
						if (typeof dataItem === 'string') {
							// 简单字符串格式
							return {
								name: dataItem,
								value: dataItem,
								description: `Table: ${dataItem}`
							};
						} else if (dataItem && typeof dataItem === 'object') {
							// 对象格式，确保有标准字段
							const tableName = dataItem.name || dataItem.value || dataItem.table_name;
							if (tableName && typeof tableName === 'string') {
								return {
									name: tableName,
									value: dataItem.value || tableName,
									description: dataItem.description || `Table: ${tableName}`
								};
							} else {
								// 如果无法提取有效的表名，跳过这个条目
								console.warn('无法从 data 字段提取有效的表名:', dataItem);
								return null;
							}
						}
						return dataItem;
					}).filter(table => table !== null); // 过滤掉无效的表

					upstreamData.tables = upstreamData.tables.concat(dataAsTableList);
				}
			}
		}

		// 调试输出
		console.log('提取的上游数据:', {
			connectionsCount: upstreamData.connections.length,
			tablesCount: upstreamData.tables.length,
			isMergedData: upstreamData.isMergedData,
			sourceInfo: upstreamData.sourceInfo,
			connections: upstreamData.connections.map(c => ({
				url: c.url.substring(0, 30) + '...',
				type: c.type,
				databaseType: c.databaseType,
				source: c.source
			})),
			tables: upstreamData.tables.slice(0, 5), // 只显示前5个表以避免日志过长
			// 添加原始数据的调试信息
			inputDataSample: items.slice(0, 2).map(item => ({
				availableFields: Object.keys(item.json || {}),
				connectionFields: Object.keys(item.json || {}).filter(key =>
					key.toLowerCase().includes('connection') ||
					key.toLowerCase().includes('url')
				),
				databaseType: item.json?.databaseType,
				connectionConfigType: (item.json?.connectionConfig as any)?.type
			})),
			// 添加 Merge 节点处理建议
			mergeNodeAdvice: upstreamData.isMergedData ? 
				'⚠️ 检测到来自 Merge 节点的数据。建议使用表达式 {{ $("NodeName").item.json.connectionUrl }} 而不是 item 0/1' : 
				'✅ 直接来自 Connector 节点的数据'
		});

		return upstreamData;
	}

	/**
	 * 测试数据库连接
	 */
	private static async testDatabaseConnection(context: IExecuteFunctions, connectionConfig: any): Promise<{success: boolean, error?: string}> {
		try {
			const testUrl = 'http://data-diff-api:8000/api/v1/test/connection';
			const response = await context.helpers.httpRequest({
				method: 'POST',
				url: testUrl,
				headers: {
					'Content-Type': 'application/json',
				},
				body: { connection_config: connectionConfig },
				json: true,
				returnFullResponse: true,
				timeout: 10000, // 10秒超时
			});

			return {
				success: response.statusCode === 200,
				error: response.statusCode !== 200 ? `HTTP ${response.statusCode}: ${response.body?.error || response.statusMessage}` : undefined
			};
		} catch (error: any) {
			return {
				success: false,
				error: error.message
			};
		}
	}

	/**
	 * 带重试机制的API调用
	 */
	private static async apiCallWithRetry(
		context: IExecuteFunctions,
		method: string,
		endpoint: string,
		data: any,
		maxRetries: number = 3,
		delayMs: number = 2000
	): Promise<any> {
		let lastError: any;
		
		for (let attempt = 1; attempt <= maxRetries; attempt++) {
			try {
				context.logger.info(`API调用尝试 ${attempt}/${maxRetries}: ${method} ${endpoint}`);
				
				const baseUrl = 'http://data-diff-api:8000/api/v1';
				const fullUrl = `${baseUrl}${endpoint}`;
				
				const response = await context.helpers.httpRequest({
					method: method as any,
					url: fullUrl,
					headers: {
						'Content-Type': 'application/json',
					},
					body: data,
					json: true,
					returnFullResponse: true,
					timeout: 300000, // 5分钟超时
				});

				// 检查HTTP状态码
				if (response.statusCode === 404) {
					throw new Error(`资源未找到: ${endpoint}`);
				}

				if (response.statusCode !== 200) {
					throw new Error(`HTTP错误: ${response.statusCode} ${response.statusMessage}`);
				}

				// 成功返回结果
				if (attempt > 1) {
					context.logger.info(`API调用在第${attempt}次尝试后成功`);
				}
				return response.body;
				
			} catch (error: any) {
				lastError = error;
				
				// 检查是否是连接相关错误
				const isConnectionError = 
					error.message.includes('connection already closed') ||
					error.message.includes('connection timeout') ||
					error.message.includes('connection refused') ||
					error.message.includes('ECONNRESET') ||
					error.message.includes('ECONNREFUSED') ||
					error.message.includes('ETIMEDOUT') ||
					error.message.includes('InterfaceError') ||
					error.message.includes('OperationalError') ||
					error.cause?.code === 'ECONNRESET' ||
					error.cause?.code === 'ECONNREFUSED' ||
					error.cause?.code === 'ETIMEDOUT';
				
				if (isConnectionError && attempt < maxRetries) {
					context.logger.warn(`连接错误，${delayMs}ms后重试 (尝试 ${attempt}/${maxRetries}): ${error.message}`);
					await DataComparison.sleep(delayMs);
					
					// 指数退避策略
					delayMs = Math.min(delayMs * 1.5, 10000);
					continue;
				}
				
				// 如果是HTTP 404错误，直接抛出，不重试
				if (error.message.includes('资源未找到') || error.message.includes('404')) {
					throw error;
				}
				
				// 如果不是连接错误或已达到最大重试次数，抛出异常
				if (attempt === maxRetries) {
					context.logger.error(`API调用失败，已达到最大重试次数: ${error.message}`);
					throw error;
				}
				
				// 其他错误也重试一次
				context.logger.warn(`API调用失败，重试 (尝试 ${attempt}/${maxRetries}): ${error.message}`);
				await DataComparison.sleep(delayMs);
			}
		}
		
		throw lastError;
	}

	/**
	 * 带重试机制的 API 调用包装器制的 API 调用包装器
	 * 专门处理数据库连接错误和网络问题专门处理数据库连接错误和网络问题
	 */
	private static async executeWithRetry<T>(
		operation: () => Promise<T>,operation: () => Promise<T>,
		context: {		context: {
			operationName: string;
			maxRetries?: number;xRetries?: number;
			baseDelay?: number;r;
			maxDelay?: number;
			retryCondition?: (error: any) => boolean;tryCondition?: (error: any) => boolean;
		}		}
	): Promise<T> {
		const {
			operationName,
			maxRetries = 3,maxRetries = 3,
			baseDelay = 1000,			baseDelay = 1000,
			maxDelay = 10000,
			retryCondition = DataComparison.isRetryableError
		} = context;

		let lastError: any;
		let attempt = 0;

		while (attempt <= maxRetries) {ies) {
			try {
				console.log(`[${operationName}] 尝试 ${attempt + 1}/${maxRetries + 1}`);1}/${maxRetries + 1}`);
				const result = await operation();t operation();
				
				if (attempt > 0) {	if (attempt > 0) {
					console.log(`[${operationName}] 重试成功，总共尝试了 ${attempt + 1} 次`);					console.log(`[${operationName}] 重试成功，总共尝试了 ${attempt + 1} 次`);
				}
				
				return result;
			} catch (error: any) {
				lastError = error;				lastError = error;
				console.error(`[${operationName}] 尝试 ${attempt + 1} 失败:`, error.message);}] 尝试 ${attempt + 1} 失败:`, error.message);

				// 如果是最后一次尝试，或者错误不可重试，直接抛出误不可重试，直接抛出
				if (attempt >= maxRetries || !retryCondition(error)) {				if (attempt >= maxRetries || !retryCondition(error)) {
					console.error(`[${operationName}] 不再重试，原因: ${attempt >= maxRetries ? '达到最大重试次数' : '错误不可重试'}`);}] 不再重试，原因: ${attempt >= maxRetries ? '达到最大重试次数' : '错误不可重试'}`);
					throw error;
				}

				// 计算延迟时间 (指数退避 + 随机抖动)
				const delay = Math.min(elay = Math.min(
					baseDelay * Math.pow(2, attempt) + Math.random() * 1000,attempt) + Math.random() * 1000,
					maxDelay
				);

				console.log(`[${operationName}] ${delay}ms 后重试...`);				console.log(`[${operationName}] ${delay}ms 后重试...`);
				await DataComparison.sleep(delay);ataComparison.sleep(delay);
				attempt++;
			}
		}

		throw lastError;
	}

	/**
	 * 判断错误是否可以重试断错误是否可以重试
	 *//
	private static isRetryableError(error: any): boolean {	private static isRetryableError(error: any): boolean {
		const errorMessage = error.message?.toLowerCase() || '';error.message?.toLowerCase() || '';
		
		// 可重试的错误类型
		const retryablePatterns = [		const retryablePatterns = [
			'connection already closed',',
			'connection reset',
			'connection refused',
			'connection timeout',
			'connection lost',
			'timeout',
			'network error',etwork error',
			'econnrefused',			'temporary failure',
			'etimedout',lable',
			'socket hang up',
			'socket timeout',
			'read timeout',
			'write timeout',enotfound',
			'connection pool exhausted',			'socket hang up',
			'max connections reached',t',
			'server temporarily unavailable'meout',
		];

		// 不可重试的错误类型'max connections reached',
		const nonRetryablePatterns = [	'server temporarily unavailable'
			'authentication failed',		];
			'invalid credentials',
			'permission denied',重试的错误类型
			'access denied',
			'not found',
			'table does not exist',			'invalid credentials',
			'database does not exist',ed',
			'invalid query',
			'syntax error',not found',
			'column does not exist',			'table does not exist',
			'invalid configuration',
			'malformed request'			'invalid query',
		];ax error',

		// 检查是否是不可重试的错误			'invalid configuration',
		for (const pattern of nonRetryablePatterns) {med request'
			if (errorMessage.includes(pattern)) {
				return false;
			}		// 检查是否是不可重试的错误
		}atterns) {

		// 检查是否是可重试的错误return false;
		for (const pattern of retryablePatterns) {			}
			if (errorMessage.includes(pattern)) {
				return true;
			} 检查是否是可重试的错误
		}		for (const pattern of retryablePatterns) {
orMessage.includes(pattern)) {
		// HTTP 状态码检查
		if (error.response) {
			const statusCode = error.response.statusCode;
			// 5xx 错误和某些 4xx 错误可以重试
			return statusCode >= 500 || statusCode === 408 || statusCode === 429; HTTP 状态码检查
		}		if (error.response) {
tatusCode = error.response.statusCode;
		// 默认不重试未知错误
		return false;atusCode === 429;
	}

	/** 默认不重试未知错误
	 * 睡眠函数		return false;
	 */
	private static sleep(ms: number): Promise<void> {
		return new Promise(resolve => setTimeout(resolve, ms));
	}
/
	private static parseConnectionString(connectionString: string): any {rivate static sleep(ms: number): Promise<void> {
		/**		return new Promise(resolve => setTimeout(resolve, ms));
		 * 解析数据库连接字符串为配置对象
		 * 支持 PostgreSQL 和 ClickZetta 格式
		 */

		// 如果传入的已经是对象（可能是从上游节点传递过来的）
		if (typeof connectionString === 'object') {ic async httpRequestWithRetry(
			return connectionString;
		}

		// PostgreSQL: postgresql://user:pass@host:port/databasePromise<any> {
		if (connectionString.startsWith('postgresql://')) {turn DataComparison.executeWithRetry(
			const url = new URL(connectionString);			async () => {
			return {le.log(`[${operationName}] 发送 HTTP 请求到:`, requestOptions.url);
				database_type: 'postgresql',tOptions);
				host: url.hostname,
				port: parseInt(url.port) || 5432,				// 检查响应是否包含应用级错误
				username: url.username,
				password: url.password,.error}`);
				database: url.pathname.substring(1), // 移除开头的 /	}
				db_schema: 'public'				
			};
		}

		// ClickZetta: clickzetta://user:pass@host/database?virtualcluster=xxx&schema=xxx: `HTTP-${operationName}`,
		if (connectionString.startsWith('clickzetta://')) {
			const url = new URL(connectionString);,
			const params = new URLSearchParams(url.search);

			// 从主机名中提取 instance 和 service 信息
			let instance = '';	}
			let service = '';

			if (url.hostname.includes('.')) {
				// 格式如 instance.service.com
				const hostParts = url.hostname.split('.');thCheck(
				instance = hostParts[0];nctions,
				service = hostParts.slice(1).join('.');
			} else {ationName: string
				// 如果没有点分隔，假设整个是 instanceromise<{healthy: boolean, latency?: number, error?: string}> {
				instance = url.hostname;		const startTime = Date.now();
				service = 'uat-api.clickzetta.com'; // 默认服务地址
			}

			return {uestWithRetry(
				database_type: 'clickzetta',				context,
				username: url.username,
				password: url.password,
				instance: instance,					url: testUrl,
				service: service,on' },
				workspace: url.pathname.substring(1) || 'default', // 移除开头的 /Config },
				db_schema: params.get('schema') || 'public', // 修改为 db_schema 以匹配 API 期望
				vcluster: params.get('virtualcluster') || 'default_ap' // 默认虚拟集群ponse: true,
			};
		}
${operationName}`
		// 如果是其他格式，尝试作为JSON解析
		try {
			const parsed = JSON.parse(connectionString);st latency = Date.now() - startTime;
			const healthy = response.statusCode === 200;
			// 确保 Clickzetta 对象有正确的字段名
			if (parsed.database_type === 'clickzetta') { ${healthy ? '✅ 健康' : '❌ 异常'}, 延迟: ${latency}ms`);
				// 如果使用 schema，转换为 db_schema
				if (parsed.schema && !parsed.db_schema) {
					parsed.db_schema = parsed.schema;
					delete parsed.schema; // 删除原来的 schema 字段，避免混淆
				}ndefined : `HTTP ${response.statusCode}: ${response.body?.error || response.statusMessage}`

				// 确保必要字段有默认值ch (error: any) {
				parsed.service = parsed.service || 'uat-api.clickzetta.com';st latency = Date.now() - startTime;
				parsed.vcluster = parsed.vcluster || 'default_ap';nsole.error(`[${operationName}] 连接健康检查失败:`, error.message);
				parsed.db_schema = parsed.db_schema || 'public';			
			} {

			return parsed;
		} catch {
			// 如果解析失败，返回原始字符串（向后兼容）			};
			throw new Error(`Unsupported connection string format: ${connectionString}`);
		}
	}

	private static generateSchemaSummary(summary: any, diff: any): string {和测试连接
		try {
			const identical = summary?.schemas_identical || false;ns(
			const totalDiffs = summary?.total_differences || 0;

			if (identical) {
				return "✅ 模式完全相同 - 两个数据库的模式结构一致";
			}ise<{success: boolean, sourceHealth?: any, targetHealth?: any, error?: string}> {
le.log(`[${operationName}] 开始连接预热...`);
			const parts: string[] = [];
 {
			// 总览			// 并行检查两个连接的健康状况
			parts.push(`📊 发现 ${totalDiffs} 个差异`);alth, targetHealth] = await Promise.all([
		DataComparison.performConnectionHealthCheck(context, sourceConfig, `${operationName}-Source`),
			// 表级差异				DataComparison.performConnectionHealthCheck(context, targetConfig, `${operationName}-Target`)
			const tablesOnlySource = diff?.tables_only_in_source || [];);
			const tablesOnlyTarget = diff?.tables_only_in_target || [];
ess = sourceHealth.healthy && targetHealth.healthy;
			if (tablesOnlySource.length > 0) {
				parts.push(`📤 仅在源数据库: ${tablesOnlySource.join(', ')}`);
			}nName}] 连接预热成功 - 源延迟: ${sourceHealth.latency}ms, 目标延迟: ${targetHealth.latency}ms`);
			} else {
			if (tablesOnlyTarget.length > 0) {接预热发现问题:`, {
				parts.push(`📥 仅在目标数据库: ${tablesOnlyTarget.join(', ')}`);ealth.healthy ? '✅' : `❌ ${sourceHealth.error}`,
			}		target: targetHealth.healthy ? '✅' : `❌ ${targetHealth.error}`
				});
			// 列级差异
			const columnDiffs = diff?.column_diffs || {};
			const columnDiffCount = Object.keys(columnDiffs).length;
			if (columnDiffCount > 0) {	success,
				parts.push(`📋 ${columnDiffCount} 个表有列差异`);				sourceHealth,
			}alth,
		error: success ? undefined : `连接预热失败: ${!sourceHealth.healthy ? `源连接: ${sourceHealth.error}` : ''}${!targetHealth.healthy ? ` 目标连接: ${targetHealth.error}` : ''}`
			// 类型差异			};
			const typeDiffs = diff?.type_diffs || {};	} catch (error: any) {
			const typeDiffCount = Object.keys(typeDiffs).length;			console.error(`[${operationName}] 连接预热异常:`, error.message);































































































































}	}		return '';		}			return tableData.value || tableData.name || tableData.table_name || '';			// 尝试不同的字段名		if (typeof tableData === 'object') {		}			return tableData;		if (typeof tableData === 'string') {		if (!tableData) return '';	private static safeExtractTableName(tableData: any): string {	 */	 * 支持多种表数据格式	 * 安全地从上游数据提取表名	/**	}		return detailed;		});			}				});					});						recommendation: '检查数据兼容性并考虑类型转换'						impact: 'high',						description: `表 "${table}" 中列 "${change.column}" 的类型不匹配: ${change.source_type} vs ${change.target_type}`,						targetType: change.target_type,						sourceType: change.source_type,						column: change.column,						table: table,						type: 'type_mismatch',					detailed.typeLevelDifferences.push({				changes.forEach((change: any) => {			if (Array.isArray(changes)) {			detailed.summary.hasTypeDifferences = true;		Object.entries(typeDiffs).forEach(([table, changes]: [string, any]) => {		const typeDiffs = diff?.type_diffs || {};		// 类型差异		});			});				});					recommendation: '检查是否需要删除此列或在源数据库中添加'					impact: 'medium',					description: `表 "${table}" 中的列 "${column}" 仅存在于目标数据库`,					column: column,					table: table,					type: 'column_missing_in_source',				detailed.columnLevelDifferences.push({			colsOnlyTarget.forEach((column: string) => {			});				});					recommendation: '在目标数据库的此表中添加该列'					impact: 'high',					description: `表 "${table}" 中的列 "${column}" 仅存在于源数据库`,					column: column,					table: table,					type: 'column_missing_in_target',				detailed.columnLevelDifferences.push({			colsOnlySource.forEach((column: string) => {			const colsOnlyTarget = diffs.columns_only_in_target || [];			const colsOnlySource = diffs.columns_only_in_source || [];			detailed.summary.hasColumnDifferences = true;		Object.entries(columnDiffs).forEach(([table, diffs]: [string, any]) => {		const columnDiffs = diff?.column_diffs || {};		// 列级差异		});			});				recommendation: '检查是否需要删除此表或在源数据库中添加'				impact: 'medium',				description: `表 "${table}" 仅存在于目标数据库中`,				table: table,				type: 'missing_in_source',			detailed.tableLevelDifferences.push({		tablesOnlyTarget.forEach((table: string) => {		});			});				recommendation: '在目标数据库中创建此表'				impact: 'high',				description: `表 "${table}" 仅存在于源数据库中`,				table: table,				type: 'missing_in_target',			detailed.tableLevelDifferences.push({		tablesOnlySource.forEach((table: string) => {		}			detailed.summary.hasTableDifferences = true;		if (tablesOnlySource.length > 0 || tablesOnlyTarget.length > 0) {		const tablesOnlyTarget = diff?.tables_only_in_target || [];		const tablesOnlySource = diff?.tables_only_in_source || [];		// 表级差异		};			}				hasTypeDifferences: false				hasColumnDifferences: false,				hasTableDifferences: false,			summary: {			typeLevelDifferences: [],			columnLevelDifferences: [],			tableLevelDifferences: [],		const detailed: any = {	private static generateDetailedDifferences(diff: any): any {	}		}			return "⚠️ 模式比对完成但摘要生成失败";		} catch (error) {			return parts.join(' | ');			}				parts.push(`🔄 ${typeDiffCount} 个表有类型差异`);			if (typeDiffCount > 0) {			return {
				success: false,
				error: `连接预热异常: ${error.message}`
			};
		}
	}

	private static async compareTables(context: IExecuteFunctions, itemIndex: number, upstreamData: any): Promise<any> {
		let sourceConnection = context.getNodeParameter('sourceConnection', itemIndex) as string;
		let targetConnection = context.getNodeParameter('targetConnection', itemIndex) as string;
		let sourceTable = context.getNodeParameter('sourceTable', itemIndex) as string;
		let targetTable = context.getNodeParameter('targetTable', itemIndex) as string;
		const keyColumns = context.getNodeParameter('keyColumns', itemIndex) as string;
		const columnsToCompare = context.getNodeParameter('columnsToCompare', itemIndex) as string;
		const whereCondition = context.getNodeParameter('whereCondition', itemIndex) as string;

		// 获取凭证
		const credentials = await context.getCredentials('dataDiffConfig');

		// 获取所有输入项以便处理 item 0/1 的情况
		const allItems = context.getInputData();

		// 检查连接字符串是否为空或 undefined，使用凭证中的默认值
		if (!sourceConnection || sourceConnection === 'undefined') {
			sourceConnection = (credentials?.defaultSourceConnection as string) || '';
			console.log('使用凭证中的默认源连接');
		}
		if (!targetConnection || targetConnection === 'undefined') {
			targetConnection = (credentials?.defaultTargetConnection as string) || '';
			console.log('使用凭证中的默认目标连接');
		}

		// 如果表名为空，尝试从上游数据获取
		if (!sourceTable && upstreamData.tables && upstreamData.tables.length > 0) {
			// 选择第一个非系统表
			const filteredTables = upstreamData.tables.filter((table: any) => {
				const name = table?.name || table?.value || table;
				return !name.startsWith('_') && !name.includes('metadata') && !name.includes('system');
			});
			sourceTable = filteredTables.length > 0 ?
				(filteredTables[0].name || filteredTables[0].value || filteredTables[0]) :
				(upstreamData.tables[0].name || upstreamData.tables[0].value || upstreamData.tables[0]);
		}

		if (!targetTable && upstreamData.tables && upstreamData.tables.length > 0) {
			// 选择第一个非系统表，但与源表不同
			const filteredTables = upstreamData.tables.filter((table: any) => {
				const name = table?.name || table?.value || table;
				return !name.startsWith('_') && !name.includes('metadata') && !name.includes('system') && name !== sourceTable;
			});
			if (filteredTables.length > 0) {
				targetTable = filteredTables[0].name || filteredTables[0].value || filteredTables[0];
			} else if (upstreamData.tables.length > 1) {
				// 如果没有合适的过滤表，选择第二个表
				targetTable = upstreamData.tables[1].name || upstreamData.tables[1].value || upstreamData.tables[1];
			} else {
				// 如果只有一个表，使用相同的表（可能是不同数据库的同名表）
				targetTable = sourceTable;
			}
		}

		console.log('连接和表信息:', {
			sourceConnection: sourceConnection ? 'present' : 'missing',
			targetConnection: targetConnection ? 'present' : 'missing',
			sourceTable: sourceTable || 'missing',
			targetTable: targetTable || 'missing',
			availableTables: upstreamData.tables?.length || 0
		});

		if (!sourceConnection) {
			throw new Error('Source connection string is required. Please:\n1. Provide it in the node parameters\n2. Set defaultSourceConnection in credentials\n3. Use drag-and-drop from upstream nodes\n4. Check if your expression (e.g., "{{ $json.connectionUrl }}") returns undefined - verify the upstream node name and field path');
		}
		if (!targetConnection) {
			throw new Error('Target connection string is required. Please:\n1. Provide it in the node parameters\n2. Set defaultTargetConnection in credentials\n3. Use drag-and-drop from upstream nodes\n4. Check if your expression (e.g., "{{ $json.connectionUrl }}") returns undefined - verify the upstream node name and field path');
		}
		if (!sourceTable) {
			throw new Error('Source table name is required');
		}
		if (!targetTable) {
			throw new Error('Target table name is required');
		}

		// 参数优先级：节点表单参数 > 凭据配置 > 默认值
		const mergedKeyColumns = keyColumns || (typeof credentials?.keyColumns === 'string' ? credentials.keyColumns : '') || 'id';
		const mergedSampleSize = (typeof credentials?.sampleSize === 'number' ? credentials.sampleSize : 0) || 10000;
		const mergedThreads = (typeof credentials?.threads === 'number' ? credentials.threads : 0) || 4;
		const mergedCaseSensitive = credentials?.caseSensitive !== undefined ? credentials.caseSensitive : true;
		const mergedTolerance = (typeof credentials?.tolerance === 'number' ? credentials.tolerance : 0) || 0.001;
		const mergedMethod = (typeof credentials?.method === 'string' ? credentials.method : '') || 'hashdiff';
		const mergedExcludeColumns = (typeof credentials?.excludeColumns === 'string' ? credentials.excludeColumns : '') || '';
		const mergedBisectionThreshold = (typeof credentials?.bisectionThreshold === 'number' ? credentials.bisectionThreshold : 0) || 1024;
		const mergedStrictTypeChecking = credentials?.strictTypeChecking !== undefined ? credentials.strictTypeChecking : false;

		// 调用API
		try {
			const apiUrl = 'http://data-diff-api:8000/api/v1/compare/tables/nested';

			// 解析列名 - 使用合并后的参数，确保类型安全
			const keyColumnsList = typeof mergedKeyColumns === 'string' && mergedKeyColumns ?
				mergedKeyColumns.split(',').map(col => col.trim()).filter(col => col) :
				['id'];

			const columnsToCompareList = typeof columnsToCompare === 'string' && columnsToCompare ?
				columnsToCompare.split(',').map(col => col.trim()).filter(col => col) :
				[];

			// 处理排除列（来自凭据），确保类型安全
			const excludeColumnsList = typeof mergedExcludeColumns === 'string' && mergedExcludeColumns ?
				mergedExcludeColumns.split(',').map(col => col.trim()).filter(col => col) :
				[];

			// 解析连接字符串为配置对象
			const sourceConfig = DataComparison.parseConnectionString(sourceConnection);
			const targetConfig = DataComparison.parseConnectionString(targetConnection);

			// 使用嵌套的 JSON 请求方式，与 nested 端点保持一致
			const requestData = {
				source_config: sourceConfig,
				target_config: targetConfig,
				comparison_config: {
					source_table: sourceTable,
					target_table: targetTable,
					key_columns: keyColumnsList,
					columns_to_compare: columnsToCompareList.length > 0 ? columnsToCompareList : undefined,
					exclude_columns: excludeColumnsList.length > 0 ? excludeColumnsList : undefined,
					sample_size: mergedSampleSize,
					threads: mergedThreads,
					case_sensitive: mergedCaseSensitive,
					tolerance: mergedTolerance,
					algorithm: mergedMethod,
					bisection_threshold: mergedBisectionThreshold,
					where_condition: whereCondition || undefined,
					strict_type_checking: mergedStrictTypeChecking
				}
			};

			console.log('发送API请求 (纯JSON方式)');
			console.log('请求URL:', apiUrl);
			console.log('请求体:', JSON.stringify(requestData, null, 2));

			// 发送请求（使用重试机制）
			try {
				const response = await DataComparison.apiCallWithRetry(
					context,
					'POST',
					'/compare/data',
					requestData,
					3,
					2000
				);

				console.log('API请求成功，响应:', JSON.stringify(response));

				// 检查 API 是否返回错误
				if (response.error) {
					throw new Error(`API返回错误: ${response.error}`);
				}

				// API 返回的是 comparison_id，直接返回而不等待结果
				const comparisonId = response.comparison_id;
				if (!comparisonId) {
					throw new Error('API 未返回比对ID');
				}

				return {
					comparisonId: comparisonId,
					status: response.body.status || 'started',
					message: response.body.message || '表比对任务已启动',
					requestData: requestData,
					apiUrl: apiUrl,
					timestamp: new Date().toISOString(),
					retrieveResultUrl: `http://data-diff-api:8000/api/v1/compare/results/${comparisonId}`,
					note: 'Use the "Get Comparison Result" operation with this comparison ID to retrieve the results'
				};
			} catch (error: any) {
				console.error('API请求失败:', error.message);
				if (error.response) {
					console.error('错误响应状态:', error.response.statusCode);
					console.error('错误响应内容:', JSON.stringify(error.response.body));
				}
				throw new Error(`启动表比对失败: ${error.message}`);
			}
		} catch (error: any) {
			throw new Error(`Data comparison API request failed: ${error.message}`);
		}
	}

	private static async compareSchemas(context: IExecuteFunctions, itemIndex: number, upstreamData: any): Promise<any> {
		let sourceConnection = context.getNodeParameter('sourceConnection', itemIndex) as string;
		let targetConnection = context.getNodeParameter('targetConnection', itemIndex) as string;

		// 智能收集所有可用的连接信息
		const allItems = context.getInputData();
		const allConnections: string[] = [];

		// 从所有输入项中收集连接信息
		for (let i = 0; i < allItems.length; i++) {
			const item = allItems[i];
			if (item.json) {
				const connectionFields = ['connectionUrl', 'connectionString', 'connection', 'url'];
				for (const field of connectionFields) {
					if (item.json[field] && typeof item.json[field] === 'string') {
						if (!allConnections.includes(item.json[field])) {
							allConnections.push(item.json[field]);
						}
					}
				}
			}
		}

		// 从节点参数中收集连接信息
		for (let i = 0; i < allItems.length; i++) {
			try {
				const srcConn = context.getNodeParameter('sourceConnection', i, '') as string;
				const tgtConn = context.getNodeParameter('targetConnection', i, '') as string;

				if (srcConn && !allConnections.includes(srcConn)) {
					allConnections.push(srcConn);
				}
				if (tgtConn && !allConnections.includes(tgtConn)) {
					allConnections.push(tgtConn);
				}
			} catch (error) {
				// 忽略参数获取错误，继续处理其他项
			}
		}

		// 从上游数据中收集连接信息
		if (upstreamData.connections && upstreamData.connections.length > 0) {
			for (const conn of upstreamData.connections) {
				if (conn.url && !allConnections.includes(conn.url)) {
					allConnections.push(conn.url);
				}
			}
		}

		// 智能分配连接信息
		if (!sourceConnection && allConnections.length > 0) {
			sourceConnection = allConnections[0];
		}
		if (!targetConnection && allConnections.length > 1) {
			targetConnection = allConnections[1];
		} else if (!targetConnection && allConnections.length > 0) {
			targetConnection = allConnections[0];
		}

		console.log('模式比较智能收集结果:', {
			itemIndex,
			allConnections: allConnections.map(c => c.substring(0, 20) + '...'),
			sourceConnection: sourceConnection ? 'present' : 'missing',
			targetConnection: targetConnection ? 'present' : 'missing',
			inputItemsCount: allItems.length
		});

		if (!sourceConnection) {
			throw new Error('Source connection string is required');