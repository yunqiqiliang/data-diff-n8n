import {
	IExecuteFunctions,
	INodeExecutionData,
	INodeType,
	INodeTypeDescription,
	NodeConnectionType,
	IDataObject,
} from 'n8n-workflow';

export class DataComparison implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'Data Comparison',
		name: 'dataComparison',
		icon: 'fa:exchange-alt',
		group: ['transform'],
		version: 1,
		description: 'Compare data between different databases using data-diff',
		defaults: {
			name: 'Data Comparison',
		},
		inputs: [NodeConnectionType.Main],
		outputs: [NodeConnectionType.Main],
		credentials: [
			{
				name: 'dataDiffConfig',
				required: true,
			},
		],
		properties: [
			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				options: [
					{
						name: 'Compare Table',
						value: 'compareTables',
						description: 'Compare two database tables',
						action: 'Compare two database tables',
					},
					{
						name: 'Compare Schema',
						value: 'compareSchemas',
						description: 'Compare database schemas',
						action: 'Compare database schemas',
					},
					{
						name: 'Get Comparison Result',
						value: 'getComparisonResult',
						description: 'Get the result of a previously started comparison',
						action: 'Get comparison result by ID',
					},
				],
				default: 'compareTables',
			},
			{
				displayName: 'Source Connection',
				name: 'sourceConnection',
				type: 'string',
				default: 'postgresql://metabase:metasample123@106.120.41.178:5436/sample',
				placeholder: 'postgresql://user:pass@host:port/db',
				description: 'âš ï¸ å…³äº "item 0/1" é€‰é¡¹ï¼š\nâ€¢ è¿™äº›é€‰é¡¹å‡ºç°æ˜¯å› ä¸ºä¸Šæ¸¸æœ‰ Merge èŠ‚ç‚¹\nâ€¢ item 0 = ç¬¬ä¸€ä¸ªæ•°æ®åº“è¿æ¥\nâ€¢ item 1 = ç¬¬äºŒä¸ªæ•°æ®åº“è¿æ¥\nâ€¢ ä½†ç›´æ¥ä½¿ç”¨å¯èƒ½å¯¼è‡´ undefined\n\nâœ… æ¨èçš„å®‰å…¨æ–¹æ³•ï¼š\n1. æŒ‡å®šèŠ‚ç‚¹å’Œç´¢å¼•ï¼š{{ $("NodeName").all()[0].json.connectionUrl }}\n2. æŒ‡å®šèŠ‚ç‚¹å’Œç´¢å¼•ï¼š{{ $("NodeName").all()[1].json.connectionUrl }}\n3. ä½¿ç”¨èŠ‚ç‚¹åï¼š{{ $("PostgreSQL Connector").item.json.connectionUrl }}\n4. ä½¿ç”¨èŠ‚ç‚¹åï¼š{{ $("ClickZetta Connector").item.json.connectionUrl }}\n5. å½“å‰è¾“å…¥ç´¢å¼•ï¼š{{ $input.all()[0].json.connectionUrl }}\n6. å¯ç”¨"è‡ªåŠ¨å¡«å……"é€‰é¡¹\n7. ä½¿ç”¨ä¸‹æ–¹çš„é»˜è®¤è¿æ¥å­—ç¬¦ä¸²\n\nğŸ’¡ ç¤ºä¾‹ï¼š{{ $("CZ Database Connector Test").all()[0].json.connectionUrl }}',
				typeOptions: {
					rows: 3,
				},
				displayOptions: {
					show: {
						operation: ['compareTables', 'compareSchemas'],
					},
				},
				required: false,
			},
			{
				displayName: 'Target Connection',
				name: 'targetConnection',
				type: 'string',
				default: 'clickzetta://qiliang:Ql123456!@jnsxwfyr.uat-api.clickzetta.com/quick_start?virtualcluster=default_ap&schema=from_pg',
				placeholder: 'clickzetta://user:pass@host:port/db',
				description: 'âš ï¸ å…³äº "item 0/1" é€‰é¡¹ï¼š\nâ€¢ è¿™äº›é€‰é¡¹å‡ºç°æ˜¯å› ä¸ºä¸Šæ¸¸æœ‰ Merge èŠ‚ç‚¹\nâ€¢ item 0 = ç¬¬ä¸€ä¸ªæ•°æ®åº“è¿æ¥\nâ€¢ item 1 = ç¬¬äºŒä¸ªæ•°æ®åº“è¿æ¥\nâ€¢ ä½†ç›´æ¥ä½¿ç”¨å¯èƒ½å¯¼è‡´ undefined\n\nâœ… æ¨èçš„å®‰å…¨æ–¹æ³•ï¼š\n1. æŒ‡å®šèŠ‚ç‚¹å’Œç´¢å¼•ï¼š{{ $("NodeName").all()[0].json.connectionUrl }}\n2. æŒ‡å®šèŠ‚ç‚¹å’Œç´¢å¼•ï¼š{{ $("NodeName").all()[1].json.connectionUrl }}\n3. ä½¿ç”¨èŠ‚ç‚¹åï¼š{{ $("PostgreSQL Connector").item.json.connectionUrl }}\n4. ä½¿ç”¨èŠ‚ç‚¹åï¼š{{ $("ClickZetta Connector").item.json.connectionUrl }}\n5. å½“å‰è¾“å…¥ç´¢å¼•ï¼š{{ $input.all()[1].json.connectionUrl }}\n6. å¯ç”¨"è‡ªåŠ¨å¡«å……"é€‰é¡¹\n7. ä½¿ç”¨ä¸‹æ–¹çš„é»˜è®¤è¿æ¥å­—ç¬¦ä¸²\n\nğŸ’¡ ç¤ºä¾‹ï¼š{{ $("CZ Database Connector Test").all()[1].json.connectionUrl }}',
				typeOptions: {
					rows: 2,
				},
				displayOptions: {
					show: {
						operation: ['compareTables', 'compareSchemas'],
					},
				},
				required: false,
			},
			{
				displayName: 'Source Table',
				name: 'sourceTable',
				type: 'string',
				default: 'invoices',
				placeholder: 'schema.table_name or {{ $("List Tables Node").item.json.tables[0].name }}',
				description: 'Source table name. Leave empty for auto-detection from upstream PostgreSQL/Database Connector nodes. Use expressions like {{ $("NodeName").item.json.tables[0].name }} for specific nodes.',
				displayOptions: {
					show: {
						operation: ['compareTables'],
					},
				},
				required: false,
			},
			{
				displayName: 'Target Table',
				name: 'targetTable',
				type: 'string',
				default: 'invoices',
				placeholder: 'schema.table_name or {{ $("List Tables Node").item.json.data[0].name }}',
				description: 'Target table name. Leave empty for auto-detection from upstream ClickZetta Connector nodes. Use expressions like {{ $("NodeName").item.json.data[0].name }} for specific nodes.',
				displayOptions: {
					show: {
						operation: ['compareTables'],
					},
				},
				required: false,
			},
			{
				displayName: 'Key Columns',
				name: 'keyColumns',
				type: 'string',
				default: 'id',
				placeholder: 'id,user_id (leave empty to use credential default)',
				description: 'Primary key columns (comma-separated). Leave empty to use the default from credentials.',
				displayOptions: {
					show: {
						operation: ['compareTables'],
					},
				},
			},
			{
				displayName: 'Columns to Compare',
				name: 'columnsToCompare',
				type: 'string',
				default: '',
				placeholder: 'name,email,status (leave empty for all columns)',
				description: 'Specific columns to compare (comma-separated, leave empty to compare all columns except excluded ones)',
				displayOptions: {
					show: {
						operation: ['compareTables'],
					},
				},
			},
			{
				displayName: 'Where Condition',
				name: 'whereCondition',
				type: 'string',
				default: '',
				placeholder: 'status = \'active\' AND created_date > \'2023-01-01\'',
				description: 'SQL WHERE condition to filter rows (optional, specific to this comparison)',
				displayOptions: {
					show: {
						operation: ['compareTables'],
					},
				},
			},
			{
				displayName: 'Auto-fill from upstream',
				name: 'autoFillFromUpstream',
				type: 'boolean',
				default: true,
				description: 'Automatically fill connection URLs and table lists from upstream DatabaseConnector/ClickzettaConnector nodes',
			},
			{
				displayName: 'Comparison ID',
				name: 'comparisonId',
				type: 'string',
				default: '',
				placeholder: 'e.g., 02f29186-e0c9-464c-8e7e-7ec66ac7c24d',
				description: 'The ID of the comparison task to get results for. Use "item 0" for first input, "item 1" for second input, or drag the comparisonId field from previous Compare Tables operation.',
				displayOptions: {
					show: {
						operation: ['getComparisonResult'],
					},
				},
				required: true,
				typeOptions: {
					alwaysOpenEditWindow: false,
					rows: 1,
				},
			},
		],
	};

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const items = this.getInputData();
		const returnData: INodeExecutionData[] = [];
		const operation = this.getNodeParameter('operation', 0) as string;
		const autoFillFromUpstream = this.getNodeParameter('autoFillFromUpstream', 0) as boolean;

		for (let i = 0; i < items.length; i++) {
			try {
				let result: any = {};

				// å°è¯•ä»ä¸Šæ¸¸èŠ‚ç‚¹è·å–è¿æ¥ä¿¡æ¯
				const upstreamData = DataComparison.extractUpstreamData(items, autoFillFromUpstream);

				switch (operation) {
					case 'compareTables':
						result = await DataComparison.compareTables(this, i, upstreamData);
						break;
					case 'compareSchemas':
						result = await DataComparison.compareSchemas(this, i, upstreamData);
						break;
					case 'getComparisonResult':
						result = await DataComparison.getComparisonResult(this, i);
						break;
					default:
						throw new Error(`Unknown operation: ${operation}`);
				}

				returnData.push({
					json: {
						operation,
						success: true,
						upstreamData: upstreamData,
						data: result,
						timestamp: new Date().toISOString(),
					},
				});
			} catch (error: any) {
				console.error('DataComparisonæ‰§è¡Œé”™è¯¯:', error);
				console.error('é”™è¯¯å †æ ˆ:', error.stack);

				// æ”¶é›†è°ƒè¯•ä¿¡æ¯
				const debugInfo: any = {
					operation,
					itemIndex: i,
					autoFillFromUpstream,
					inputItemsCount: items.length,
					error: error?.message || 'Unknown error',
					errorStack: error?.stack || 'No stack trace available',
					timestamp: new Date().toISOString(),
				};

				// å®‰å…¨åœ°æ·»åŠ ä¸Šæ¸¸æ•°æ®ä¿¡æ¯
				try {
					const upstreamData = DataComparison.extractUpstreamData(items, autoFillFromUpstream);
					debugInfo.upstreamData = {
						connectionsCount: upstreamData?.connections?.length || 0,
						tablesCount: upstreamData?.tables?.length || 0,
						connections: upstreamData?.connections || [],
						tables: upstreamData?.tables || []
					};
				} catch (extractError) {
					debugInfo.upstreamDataError = extractError?.message || 'Failed to extract upstream data';
				}

				// å°è¯•è·å–èŠ‚ç‚¹å‚æ•°
				try {
					debugInfo.nodeParameters = {
						sourceConnection: this.getNodeParameter('sourceConnection', i, ''),
						targetConnection: this.getNodeParameter('targetConnection', i, ''),
						sourceTable: this.getNodeParameter('sourceTable', i, ''),
						targetTable: this.getNodeParameter('targetTable', i, ''),
					};
				} catch (paramError) {
					debugInfo.nodeParametersError = paramError?.message || 'Failed to get node parameters';
				}

				// åˆ†æé”™è¯¯ç±»å‹å¹¶æä¾›æ”¹è¿›å»ºè®®
				let errorCategory = 'unknown';
				let improvementSuggestions: string[] = [];

				if (error.message.includes('connection already closed')) {
					errorCategory = 'database_connection_closed';
					improvementSuggestions = [
						'ğŸ”„ ç«‹å³é‡è¯•ï¼šè¿™é€šå¸¸æ˜¯ä¸´æ—¶çš„è¿æ¥é—®é¢˜',
						'ğŸ”§ æ£€æŸ¥æ•°æ®åº“æœåŠ¡å™¨è´Ÿè½½å’Œè¿æ¥æ± é…ç½®',
						'â° éªŒè¯æ•°æ®åº“è¿æ¥è¶…æ—¶è®¾ç½®ï¼ˆé€šå¸¸éœ€è¦ > 30ç§’ï¼‰',
						'ğŸŒ ç¡®è®¤ç½‘ç»œè¿æ¥ç¨³å®šæ€§ï¼ˆç‰¹åˆ«æ˜¯è·¨ç½‘ç»œç¯å¢ƒï¼‰',
						'ğŸ“Š æ£€æŸ¥æ•°æ®åº“æœåŠ¡å™¨æ˜¯å¦æœ‰è¿æ¥æ•°é™åˆ¶',
						'ğŸ” æŸ¥çœ‹æ•°æ®åº“æ—¥å¿—ä»¥äº†è§£è¿æ¥å…³é—­åŸå› ',
						'âš™ï¸ è€ƒè™‘åœ¨data-diff APIä¸­å¢åŠ è¿æ¥é‡è¯•æœºåˆ¶',
						'ğŸ¥ æ£€æŸ¥æ•°æ®åº“æœåŠ¡å™¨å¥åº·çŠ¶å†µå’Œå†…å­˜ä½¿ç”¨æƒ…å†µ'
					];
				} else if (error.message.includes('timeout')) {
					errorCategory = 'timeout';
					improvementSuggestions = [
						'æ£€æŸ¥ç½‘ç»œè¿æ¥é€Ÿåº¦',
						'éªŒè¯æ•°æ®åº“æœåŠ¡å™¨è´Ÿè½½',
						'è€ƒè™‘åˆ†æ‰¹å¤„ç†å¤§é‡æ•°æ®',
						'æ£€æŸ¥é˜²ç«å¢™è®¾ç½®',
						'ç¡®è®¤APIæœåŠ¡çŠ¶æ€'
					];
				} else if (error.message.includes('authentication') || error.message.includes('è®¤è¯')) {
					errorCategory = 'authentication';
					improvementSuggestions = [
						'æ£€æŸ¥æ•°æ®åº“ç”¨æˆ·åå’Œå¯†ç ',
						'éªŒè¯æ•°æ®åº“ç”¨æˆ·æƒé™',
						'ç¡®è®¤æ•°æ®åº“å…è®¸è¿œç¨‹è¿æ¥',
						'æ£€æŸ¥è¯ä¹¦å’ŒSSLé…ç½®'
					];
				} else if (error.message.includes('not found') || error.message.includes('ä¸å­˜åœ¨')) {
					errorCategory = 'resource_not_found';
					improvementSuggestions = [
						'æ£€æŸ¥æ•°æ®åº“åç§°æ˜¯å¦æ­£ç¡®',
						'éªŒè¯è¡¨åå’Œschemaåç§°',
						'ç¡®è®¤æ•°æ®åº“ç”¨æˆ·æœ‰è®¿é—®æƒé™',
						'æ£€æŸ¥å¤§å°å†™æ•æ„Ÿæ€§'
					];
				} else if (error.message.includes('ECONNREFUSED') || error.message.includes('è¿æ¥å¤±è´¥')) {
					errorCategory = 'connection_refused';
					improvementSuggestions = [
						'æ£€æŸ¥APIæœåŠ¡æ˜¯å¦è¿è¡Œ',
						'éªŒè¯Dockerå®¹å™¨çŠ¶æ€',
						'æ£€æŸ¥ç«¯å£æ˜¯å¦è¢«å ç”¨',
						'ç¡®è®¤ç½‘ç»œé…ç½®æ­£ç¡®'
					];
				}

				debugInfo.errorAnalysis = {
					category: errorCategory,
					suggestions: improvementSuggestions
				};

				returnData.push({
					json: {
						operation,
						success: false,
						error: error?.message || 'Unknown error',
						errorCategory,
						improvementSuggestions,
						debugInfo,
						timestamp: new Date().toISOString(),
					},
				});
			}
		}

		return [returnData];
	}

	private static async compareTables(context: IExecuteFunctions, itemIndex: number, upstreamData: any): Promise<any> {
		let sourceConnection = context.getNodeParameter('sourceConnection', itemIndex) as string;
		let targetConnection = context.getNodeParameter('targetConnection', itemIndex) as string;
		let sourceTable = context.getNodeParameter('sourceTable', itemIndex) as string;
		let targetTable = context.getNodeParameter('targetTable', itemIndex) as string;
		const keyColumns = context.getNodeParameter('keyColumns', itemIndex) as string;
		const columnsToCompare = context.getNodeParameter('columnsToCompare', itemIndex) as string;
		const whereCondition = context.getNodeParameter('whereCondition', itemIndex) as string;

		// è·å–å‡­è¯
		const credentials = await context.getCredentials('dataDiffConfig');

		// è·å–æ‰€æœ‰è¾“å…¥é¡¹ä»¥ä¾¿å¤„ç† item 0/1 çš„æƒ…å†µ
		const allItems = context.getInputData();

		// æ£€æŸ¥è¿æ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºç©ºæˆ– undefinedï¼Œä½¿ç”¨å‡­è¯ä¸­çš„é»˜è®¤å€¼
		if (!sourceConnection || sourceConnection === 'undefined') {
			sourceConnection = (credentials?.defaultSourceConnection as string) || '';
			console.log('ä½¿ç”¨å‡­è¯ä¸­çš„é»˜è®¤æºè¿æ¥');
		}
		if (!targetConnection || targetConnection === 'undefined') {
			targetConnection = (credentials?.defaultTargetConnection as string) || '';
			console.log('ä½¿ç”¨å‡­è¯ä¸­çš„é»˜è®¤ç›®æ ‡è¿æ¥');
		}

		// å¦‚æœè¡¨åä¸ºç©ºï¼Œå°è¯•ä»ä¸Šæ¸¸æ•°æ®è·å–
		if (!sourceTable && upstreamData.tables && upstreamData.tables.length > 0) {
			// é€‰æ‹©ç¬¬ä¸€ä¸ªéç³»ç»Ÿè¡¨
			const filteredTables = upstreamData.tables.filter((table: any) => {
				const name = table?.name || table?.value || table;
				return !name.startsWith('_') && !name.includes('metadata') && !name.includes('system');
			});
			sourceTable = filteredTables.length > 0 ?
				(filteredTables[0].name || filteredTables[0].value || filteredTables[0]) :
				(upstreamData.tables[0].name || upstreamData.tables[0].value || upstreamData.tables[0]);
		}

		if (!targetTable && upstreamData.tables && upstreamData.tables.length > 0) {
			// é€‰æ‹©ç¬¬ä¸€ä¸ªéç³»ç»Ÿè¡¨ï¼Œä½†ä¸æºè¡¨ä¸åŒ
			const filteredTables = upstreamData.tables.filter((table: any) => {
				const name = table?.name || table?.value || table;
				return !name.startsWith('_') && !name.includes('metadata') && !name.includes('system') && name !== sourceTable;
			});
			if (filteredTables.length > 0) {
				targetTable = filteredTables[0].name || filteredTables[0].value || filteredTables[0];
			} else if (upstreamData.tables.length > 1) {
				// å¦‚æœæ²¡æœ‰åˆé€‚çš„è¿‡æ»¤è¡¨ï¼Œé€‰æ‹©ç¬¬äºŒä¸ªè¡¨
				targetTable = upstreamData.tables[1].name || upstreamData.tables[1].value || upstreamData.tables[1];
			} else {
				// å¦‚æœåªæœ‰ä¸€ä¸ªè¡¨ï¼Œä½¿ç”¨ç›¸åŒçš„è¡¨ï¼ˆå¯èƒ½æ˜¯ä¸åŒæ•°æ®åº“çš„åŒåè¡¨ï¼‰
				targetTable = sourceTable;
			}
		}

		console.log('è¿æ¥å’Œè¡¨ä¿¡æ¯:', {
			sourceConnection: sourceConnection ? 'present' : 'missing',
			targetConnection: targetConnection ? 'present' : 'missing',
			sourceTable: sourceTable || 'missing',
			targetTable: targetTable || 'missing',
			availableTables: upstreamData.tables?.length || 0
		});

		if (!sourceConnection) {
			throw new Error('Source connection string is required. Please:\n1. Provide it in the node parameters\n2. Set defaultSourceConnection in credentials\n3. Use drag-and-drop from upstream nodes\n4. Check if your expression (e.g., "{{ $json.connectionUrl }}") returns undefined - verify the upstream node name and field path');
		}
		if (!targetConnection) {
			throw new Error('Target connection string is required. Please:\n1. Provide it in the node parameters\n2. Set defaultTargetConnection in credentials\n3. Use drag-and-drop from upstream nodes\n4. Check if your expression (e.g., "{{ $json.connectionUrl }}") returns undefined - verify the upstream node name and field path');
		}
		if (!sourceTable) {
			throw new Error('Source table name is required');
		}
		if (!targetTable) {
			throw new Error('Target table name is required');
		}

		// å‚æ•°ä¼˜å…ˆçº§ï¼šèŠ‚ç‚¹è¡¨å•å‚æ•° > å‡­æ®é…ç½® > é»˜è®¤å€¼
		const mergedKeyColumns = keyColumns || (typeof credentials?.keyColumns === 'string' ? credentials.keyColumns : '') || 'id';
		const mergedSampleSize = (typeof credentials?.sampleSize === 'number' ? credentials.sampleSize : 0) || 10000;
		const mergedThreads = (typeof credentials?.threads === 'number' ? credentials.threads : 0) || 4;
		const mergedCaseSensitive = credentials?.caseSensitive !== undefined ? credentials.caseSensitive : true;
		const mergedTolerance = (typeof credentials?.tolerance === 'number' ? credentials.tolerance : 0) || 0.001;
		const mergedMethod = (typeof credentials?.method === 'string' ? credentials.method : '') || 'hashdiff';
		const mergedExcludeColumns = (typeof credentials?.excludeColumns === 'string' ? credentials.excludeColumns : '') || '';
		const mergedBisectionThreshold = (typeof credentials?.bisectionThreshold === 'number' ? credentials.bisectionThreshold : 0) || 1024;
		const mergedStrictTypeChecking = credentials?.strictTypeChecking !== undefined ? credentials.strictTypeChecking : false;

		// è°ƒç”¨API
		try {
			const apiUrl = 'http://data-diff-api:8000/api/v1/compare/tables/nested';

			// è§£æåˆ—å - ä½¿ç”¨åˆå¹¶åçš„å‚æ•°ï¼Œç¡®ä¿ç±»å‹å®‰å…¨
			const keyColumnsList = typeof mergedKeyColumns === 'string' && mergedKeyColumns ?
				mergedKeyColumns.split(',').map(col => col.trim()).filter(col => col) :
				['id'];

			const columnsToCompareList = typeof columnsToCompare === 'string' && columnsToCompare ?
				columnsToCompare.split(',').map(col => col.trim()).filter(col => col) :
				[];

			// å¤„ç†æ’é™¤åˆ—ï¼ˆæ¥è‡ªå‡­æ®ï¼‰ï¼Œç¡®ä¿ç±»å‹å®‰å…¨
			const excludeColumnsList = typeof mergedExcludeColumns === 'string' && mergedExcludeColumns ?
				mergedExcludeColumns.split(',').map(col => col.trim()).filter(col => col) :
				[];

			// è§£æè¿æ¥å­—ç¬¦ä¸²ä¸ºé…ç½®å¯¹è±¡
			const sourceConfig = DataComparison.parseConnectionString(sourceConnection);
			const targetConfig = DataComparison.parseConnectionString(targetConnection);

			// ä½¿ç”¨åµŒå¥—çš„ JSON è¯·æ±‚æ–¹å¼ï¼Œä¸ nested ç«¯ç‚¹ä¿æŒä¸€è‡´
			const requestData = {
				source_config: sourceConfig,
				target_config: targetConfig,
				comparison_config: {
					source_table: sourceTable,
					target_table: targetTable,
					key_columns: keyColumnsList,
					columns_to_compare: columnsToCompareList.length > 0 ? columnsToCompareList : undefined,
					exclude_columns: excludeColumnsList.length > 0 ? excludeColumnsList : undefined,
					sample_size: mergedSampleSize,
					threads: mergedThreads,
					case_sensitive: mergedCaseSensitive,
					tolerance: mergedTolerance,
					algorithm: mergedMethod,
					bisection_threshold: mergedBisectionThreshold,
					where_condition: whereCondition || undefined,
					strict_type_checking: mergedStrictTypeChecking
				}
			};

			console.log('å‘é€APIè¯·æ±‚ (çº¯JSONæ–¹å¼)');
			console.log('è¯·æ±‚URL:', apiUrl);
			console.log('è¯·æ±‚ä½“:', JSON.stringify(requestData, null, 2));

			// å‘é€è¯·æ±‚ï¼ˆä½¿ç”¨é‡è¯•æœºåˆ¶ï¼‰
			try {
				const response = await DataComparison.apiCallWithRetry(
					context,
					'POST',
					'/compare/data',
					requestData,
					3,
					2000
				);

				console.log('APIè¯·æ±‚æˆåŠŸï¼Œå“åº”:', JSON.stringify(response));

				// æ£€æŸ¥ API æ˜¯å¦è¿”å›é”™è¯¯
				if (response.error) {
					throw new Error(`APIè¿”å›é”™è¯¯: ${response.error}`);
				}

				// API è¿”å›çš„æ˜¯ comparison_idï¼Œç›´æ¥è¿”å›è€Œä¸ç­‰å¾…ç»“æœ
				const comparisonId = response.comparison_id;
				if (!comparisonId) {
					throw new Error('API æœªè¿”å›æ¯”å¯¹ID');
				}

				return {
					comparisonId: comparisonId,
					status: response.body.status || 'started',
					message: response.body.message || 'è¡¨æ¯”å¯¹ä»»åŠ¡å·²å¯åŠ¨',
					requestData: requestData,
					apiUrl: apiUrl,
					timestamp: new Date().toISOString(),
					retrieveResultUrl: `http://data-diff-api:8000/api/v1/compare/results/${comparisonId}`,
					note: 'Use the "Get Comparison Result" operation with this comparison ID to retrieve the results'
				};
			} catch (error: any) {
				console.error('APIè¯·æ±‚å¤±è´¥:', error.message);
				if (error.response) {
					console.error('é”™è¯¯å“åº”çŠ¶æ€:', error.response.statusCode);
					console.error('é”™è¯¯å“åº”å†…å®¹:', JSON.stringify(error.response.body));
				}
				throw new Error(`å¯åŠ¨è¡¨æ¯”å¯¹å¤±è´¥: ${error.message}`);
			}
		} catch (error: any) {
			throw new Error(`Data comparison API request failed: ${error.message}`);
		}
	}

	private static async compareSchemas(context: IExecuteFunctions, itemIndex: number, upstreamData: any): Promise<any> {
		let sourceConnection = context.getNodeParameter('sourceConnection', itemIndex) as string;
		let targetConnection = context.getNodeParameter('targetConnection', itemIndex) as string;

		// æ™ºèƒ½æ”¶é›†æ‰€æœ‰å¯ç”¨çš„è¿æ¥ä¿¡æ¯
		const allItems = context.getInputData();
		const allConnections: string[] = [];

		// ä»æ‰€æœ‰è¾“å…¥é¡¹ä¸­æ”¶é›†è¿æ¥ä¿¡æ¯
		for (let i = 0; i < allItems.length; i++) {
			const item = allItems[i];
			if (item.json) {
				const connectionFields = ['connectionUrl', 'connectionString', 'connection', 'url'];
				for (const field of connectionFields) {
					if (item.json[field] && typeof item.json[field] === 'string') {
						if (!allConnections.includes(item.json[field])) {
							allConnections.push(item.json[field]);
						}
					}
				}
			}
		}

		// ä»èŠ‚ç‚¹å‚æ•°ä¸­æ”¶é›†è¿æ¥ä¿¡æ¯
		for (let i = 0; i < allItems.length; i++) {
			try {
				const srcConn = context.getNodeParameter('sourceConnection', i, '') as string;
				const tgtConn = context.getNodeParameter('targetConnection', i, '') as string;

				if (srcConn && !allConnections.includes(srcConn)) {
					allConnections.push(srcConn);
				}
				if (tgtConn && !allConnections.includes(tgtConn)) {
					allConnections.push(tgtConn);
				}
			} catch (error) {
				// å¿½ç•¥å‚æ•°è·å–é”™è¯¯ï¼Œç»§ç»­å¤„ç†å…¶ä»–é¡¹
			}
		}

		// ä»ä¸Šæ¸¸æ•°æ®ä¸­æ”¶é›†è¿æ¥ä¿¡æ¯
		if (upstreamData.connections && upstreamData.connections.length > 0) {
			for (const conn of upstreamData.connections) {
				if (conn.url && !allConnections.includes(conn.url)) {
					allConnections.push(conn.url);
				}
			}
		}

		// æ™ºèƒ½åˆ†é…è¿æ¥ä¿¡æ¯
		if (!sourceConnection && allConnections.length > 0) {
			sourceConnection = allConnections[0];
		}
		if (!targetConnection && allConnections.length > 1) {
			targetConnection = allConnections[1];
		} else if (!targetConnection && allConnections.length > 0) {
			targetConnection = allConnections[0];
		}

		console.log('æ¨¡å¼æ¯”è¾ƒæ™ºèƒ½æ”¶é›†ç»“æœ:', {
			itemIndex,
			allConnections: allConnections.map(c => c.substring(0, 20) + '...'),
			sourceConnection: sourceConnection ? 'present' : 'missing',
			targetConnection: targetConnection ? 'present' : 'missing',
			inputItemsCount: allItems.length
		});

		if (!sourceConnection) {
			throw new Error('Source connection string is required');
		}
		if (!targetConnection) {
			throw new Error('Target connection string is required');
		}

		// è°ƒç”¨API - ä½¿ç”¨åµŒå¥—ç«¯ç‚¹
		try {
			const apiUrl = 'http://data-diff-api:8000/api/v1/compare/schemas/nested';

			// è§£æè¿æ¥å­—ç¬¦ä¸²ä¸ºé…ç½®å¯¹è±¡
			const sourceConfig = DataComparison.parseConnectionString(sourceConnection);
			const targetConfig = DataComparison.parseConnectionString(targetConnection);

			// ä½¿ç”¨åµŒå¥—çš„ JSON è¯·æ±‚æ–¹å¼
			const requestData = {
				source_config: sourceConfig,
				target_config: targetConfig
			};
		console.log('å‘é€æ¨¡å¼æ¯”å¯¹APIè¯·æ±‚ (åµŒå¥—JSONæ–¹å¼)');
		console.log('è¯·æ±‚URL:', apiUrl);
		console.log('è¯·æ±‚ä½“:', JSON.stringify(requestData, null, 2));
		
		// æ·»åŠ è¿æ¥è¯Šæ–­ä¿¡æ¯
		console.log('=== è¿æ¥è¯Šæ–­ä¿¡æ¯ ===');
		console.log('æºæ•°æ®åº“è¿æ¥:', {
			type: sourceConfig.type,
			host: sourceConfig.host,
			port: sourceConfig.port,
			database: sourceConfig.database,
			hasCredentials: !!(sourceConfig.username && sourceConfig.password)
		});
		console.log('ç›®æ ‡æ•°æ®åº“è¿æ¥:', {
			type: targetConfig.type,
			host: targetConfig.host,
			port: targetConfig.port,
			database: targetConfig.database,
			hasCredentials: !!(targetConfig.username && targetConfig.password)
		});
		console.log('========================');

		// é¢„å…ˆæµ‹è¯•æ•°æ®åº“è¿æ¥ï¼ˆå¯é€‰ï¼Œç”¨äºæ›´å¥½çš„é”™è¯¯è¯Šæ–­ï¼‰
		try {
			console.log('æ­£åœ¨æµ‹è¯•æºæ•°æ®åº“è¿æ¥...');
			const sourceTest = await DataComparison.testDatabaseConnection(context, sourceConfig);
			console.log('æºæ•°æ®åº“è¿æ¥æµ‹è¯•ç»“æœ:', sourceTest);
			
			console.log('æ­£åœ¨æµ‹è¯•ç›®æ ‡æ•°æ®åº“è¿æ¥...');
			const targetTest = await DataComparison.testDatabaseConnection(context, targetConfig);
			console.log('ç›®æ ‡æ•°æ®åº“è¿æ¥æµ‹è¯•ç»“æœ:', targetTest);
			
			// å¦‚æœè¿æ¥æµ‹è¯•å¤±è´¥ï¼Œæä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
			if (!sourceTest.success || !targetTest.success) {
				let errorMsg = 'æ•°æ®åº“è¿æ¥æµ‹è¯•å¤±è´¥:\n';
				if (!sourceTest.success) {
					errorMsg += `æºæ•°æ®åº“è¿æ¥å¤±è´¥: ${sourceTest.error}\n`;
				}
				if (!targetTest.success) {
					errorMsg += `ç›®æ ‡æ•°æ®åº“è¿æ¥å¤±è´¥: ${targetTest.error}\n`;
				}
				errorMsg += '\nè¯·æ£€æŸ¥æ•°æ®åº“è¿æ¥é…ç½®ã€ç½‘ç»œè¿æ¥å’Œæ•°æ®åº“æœåŠ¡çŠ¶æ€ã€‚';
				console.warn(errorMsg);
				// æ³¨æ„ï¼šè¿™é‡Œåªæ˜¯è­¦å‘Šï¼Œä¸æŠ›å‡ºå¼‚å¸¸ï¼Œå› ä¸ºAPIå¯èƒ½æœ‰ä¸åŒçš„è¿æ¥æµ‹è¯•ç«¯ç‚¹
			}
		} catch (connectionTestError: any) {
			console.warn('è¿æ¥æµ‹è¯•å¤±è´¥ï¼ˆå°†ç»§ç»­å°è¯•æ¯”å¯¹ï¼‰:', connectionTestError.message);
		}

			try {
				const response = await DataComparison.apiCallWithRetry(
					context,
					'POST',
					'/compare/schema',
					requestData,
					3,
					2000
				);

				console.log('æ¨¡å¼æ¯”å¯¹APIå“åº”:', JSON.stringify(response));

				// æ£€æŸ¥ API æ˜¯å¦è¿”å›é”™è¯¯
				if (response.error) {
					throw new Error(`APIè¿”å›é”™è¯¯: ${response.error}`);
				}

				// æ ¼å¼åŒ–è¿”å›ç»“æœ
				const result = response.result;
				const summary = result.summary || {};
				const diff = result.diff || {};

				// ç”Ÿæˆè¯¦ç»†çš„å·®å¼‚æ˜ç»†
				const detailedDifferences = DataComparison.generateDetailedDifferences(diff);
				const executionSummary = DataComparison.generateSchemaSummary(summary, diff);

				return {
					status: response.body.status || 'completed',
					sourceType: response.body.source_type,
					targetType: response.body.target_type,
					summary: {
						identical: summary.schemas_identical || false,
						totalDifferences: summary.total_differences || 0,
						tableDifferences: summary.table_differences || 0,
						columnDifferences: summary.column_differences || 0,
						typeDifferences: summary.type_differences || 0
					},
					differences: {
						tablesOnlyInSource: diff.tables_only_in_source || [],
						tablesOnlyInTarget: diff.tables_only_in_target || [],
						commonTables: diff.common_tables || [],
						columnDifferences: diff.column_diffs || {},
						typeDifferences: diff.type_diffs || {}
					},
					// æ·»åŠ è¯¦ç»†çš„å·®å¼‚æ˜ç»†
					detailedDifferences: detailedDifferences,
					sourceSchema: {
						databaseType: result.source_schema?.database_type,
						schemaName: result.source_schema?.schema_name,
						totalTables: result.source_schema?.tables?.length || 0,
						tables: result.source_schema?.tables || []
					},
					targetSchema: {
						databaseType: result.target_schema?.database_type,
						schemaName: result.target_schema?.schema_name,
						totalTables: result.target_schema?.tables?.length || 0,
						tables: result.target_schema?.tables || []
					},
					// æ‰§è¡Œæ‘˜è¦ï¼ˆå‹å¥½çš„æ–‡æœ¬æè¿°ï¼‰
					executionSummary: executionSummary,
					requestData: requestData,
					apiUrl: apiUrl,
					timestamp: result.timestamp || new Date().toISOString(),
					// æ­£ç¡®ä½¿ç”¨executionTimeå­—æ®µ
					executionTime: 'æ¨¡å¼æ¯”å¯¹å·²å®Œæˆ',
					// æ·»åŠ å¤„ç†æ—¶é—´ä¿¡æ¯
					processedAt: new Date().toISOString(),
					duration: 'instant' // æ¨¡å¼æ¯”å¯¹é€šå¸¸å¾ˆå¿«
				};		} catch (error: any) {
			console.error('æ¨¡å¼æ¯”å¯¹APIè¯·æ±‚å¤±è´¥:', error.message);
			console.error('é”™è¯¯è¯¦æƒ…:', error);
			
			// è¯¦ç»†çš„é”™è¯¯åˆ†æå’Œå¤„ç†
			let errorMessage = 'æ¨¡å¼æ¯”å¯¹å¤±è´¥';
			let errorDetails = '';
			
			if (error.response) {
				console.error('é”™è¯¯å“åº”çŠ¶æ€:', error.response.statusCode);
				console.error('é”™è¯¯å“åº”å†…å®¹:', JSON.stringify(error.response.body));
				
				if (error.response.body && error.response.body.error) {
					errorDetails = error.response.body.error;
					
					// é’ˆå¯¹å¸¸è§çš„æ•°æ®åº“è¿æ¥é”™è¯¯æä¾›æ›´å¥½çš„é”™è¯¯ä¿¡æ¯
					if (errorDetails.includes('connection already closed')) {
						errorMessage = 'æ•°æ®åº“è¿æ¥å·²å…³é—­';
						errorDetails = 'æ•°æ®åº“è¿æ¥åœ¨æ¯”å¯¹è¿‡ç¨‹ä¸­è¢«æ„å¤–å…³é—­ã€‚è¿™å¯èƒ½æ˜¯å› ä¸ºï¼š\n' +
							'1. æ•°æ®åº“è¿æ¥è¶…æ—¶\n' +
							'2. æ•°æ®åº“æœåŠ¡å™¨é‡å¯æˆ–ä¸å¯è®¿é—®\n' +
							'3. ç½‘ç»œè¿æ¥ä¸­æ–­\n' +
							'4. æ•°æ®åº“è¿æ¥æ± é…ç½®é—®é¢˜\n' +
							'è¯·æ£€æŸ¥æ•°æ®åº“è¿æ¥é…ç½®å¹¶é‡è¯•ã€‚';
					} else if (errorDetails.includes('timeout')) {
						errorMessage = 'æ•°æ®åº“è¿æ¥è¶…æ—¶';
						errorDetails = 'æ•°æ®åº“è¿æ¥è¶…æ—¶ã€‚è¯·æ£€æŸ¥ï¼š\n' +
							'1. æ•°æ®åº“æœåŠ¡å™¨æ˜¯å¦æ­£å¸¸è¿è¡Œ\n' +
							'2. ç½‘ç»œè¿æ¥æ˜¯å¦ç¨³å®š\n' +
							'3. æ•°æ®åº“è´Ÿè½½æ˜¯å¦è¿‡é«˜\n' +
							'4. è¿æ¥é…ç½®æ˜¯å¦æ­£ç¡®';
					} else if (errorDetails.includes('authentication')) {
						errorMessage = 'æ•°æ®åº“è®¤è¯å¤±è´¥';
						errorDetails = 'æ•°æ®åº“è®¤è¯å¤±è´¥ã€‚è¯·æ£€æŸ¥ï¼š\n' +
							'1. ç”¨æˆ·åå’Œå¯†ç æ˜¯å¦æ­£ç¡®\n' +
							'2. æ•°æ®åº“ç”¨æˆ·æ˜¯å¦æœ‰è¶³å¤Ÿçš„æƒé™\n' +
							'3. æ•°æ®åº“æ˜¯å¦å…è®¸è¿œç¨‹è¿æ¥';
					} else if (errorDetails.includes('does not exist') || errorDetails.includes('not found')) {
						errorMessage = 'æ•°æ®åº“æˆ–è¡¨ä¸å­˜åœ¨';
						errorDetails = 'æŒ‡å®šçš„æ•°æ®åº“ã€schemaæˆ–è¡¨ä¸å­˜åœ¨ã€‚è¯·æ£€æŸ¥ï¼š\n' +
							'1. æ•°æ®åº“åç§°æ˜¯å¦æ­£ç¡®\n' +
							'2. Schemaåç§°æ˜¯å¦æ­£ç¡®\n' +
							'3. è¡¨åç§°æ˜¯å¦æ­£ç¡®\n' +
							'4. æ•°æ®åº“ç”¨æˆ·æ˜¯å¦æœ‰è®¿é—®æƒé™';
					}
				}
			} else if (error.message.includes('ECONNREFUSED')) {
				errorMessage = 'APIæœåŠ¡è¿æ¥å¤±è´¥';
				errorDetails = 'data-diff APIæœåŠ¡æ— æ³•è¿æ¥ã€‚è¯·æ£€æŸ¥ï¼š\n' +
					'1. APIæœåŠ¡æ˜¯å¦æ­£åœ¨è¿è¡Œ\n' +
					'2. Dockerå®¹å™¨æ˜¯å¦æ­£å¸¸å¯åŠ¨\n' +
					'3. ç½‘ç»œé…ç½®æ˜¯å¦æ­£ç¡®';
			} else if (error.message.includes('ETIMEDOUT')) {
				errorMessage = 'APIè¯·æ±‚è¶…æ—¶';
				errorDetails = 'APIè¯·æ±‚è¶…æ—¶ã€‚è¯·æ£€æŸ¥ï¼š\n' +
					'1. ç½‘ç»œè¿æ¥æ˜¯å¦ç¨³å®š\n' +
					'2. APIæœåŠ¡æ˜¯å¦å“åº”æ­£å¸¸\n' +
					'3. æ•°æ®é‡æ˜¯å¦è¿‡å¤§å¯¼è‡´å¤„ç†æ—¶é—´è¿‡é•¿';
			}
			
			// æ„å»ºå‹å¥½çš„é”™è¯¯æ¶ˆæ¯
			const friendlyError = errorDetails ? 
				`${errorMessage}: ${errorDetails}` : 
				`${errorMessage}: ${error.message}`;
			
			throw new Error(friendlyError);
		}
		} catch (error: any) {
			throw new Error(`Schema comparison API request failed: ${error.message}`);
		}
	}

	private static async getComparisonResult(context: IExecuteFunctions, itemIndex: number): Promise<any> {
		const comparisonId = context.getNodeParameter('comparisonId', itemIndex) as string;

		if (!comparisonId) {
			throw new Error('Comparison ID is required');
		}

		// è°ƒç”¨ API è·å–æ¯”å¯¹ç»“æœï¼ˆä½¿ç”¨é‡è¯•æœºåˆ¶ï¼‰
		try {
			const response = await DataComparison.apiCallWithRetry(
				context,
				'GET',
				`/compare/results/${comparisonId}`,
				null,
				3,
				2000
			);

			// æ£€æŸ¥å“åº”æ˜¯å¦æœ‰æ•ˆ
			if (!response) {
				throw new Error(`Empty response for comparison ID: ${comparisonId}`);
			}

			return {
				comparisonId,
				resultUrl: `http://data-diff-api:8000/api/v1/compare/results/${comparisonId}`,
				status: 'completed',
				data: response,
				retrievedAt: new Date().toISOString(),
			};
		} catch (error: any) {
			console.error('è·å–æ¯”å¯¹ç»“æœå¤±è´¥:', error.message);
			console.error('é”™è¯¯è¯¦æƒ…:', error);
			
			// è¯¦ç»†çš„é”™è¯¯åˆ†æå’Œå¤„ç†
			let errorMessage = 'è·å–æ¯”å¯¹ç»“æœå¤±è´¥';
			let errorDetails = '';
			
			if (error.message.includes('ECONNREFUSED') || error.message.includes('connect')) {
				errorMessage = 'APIæœåŠ¡è¿æ¥å¤±è´¥';
				errorDetails = `æ— æ³•è¿æ¥åˆ° data-diff API æœåŠ¡ (http://data-diff-api:8000)ã€‚è¯·æ£€æŸ¥ï¼š\n` +
					'1. API æœåŠ¡æ˜¯å¦æ­£åœ¨è¿è¡Œ\n' +
					'2. Docker å®¹å™¨æ˜¯å¦æ­£å¸¸å¯åŠ¨\n' +
					'3. ç½‘ç»œé…ç½®æ˜¯å¦æ­£ç¡®\n' +
					'4. é˜²ç«å¢™æ˜¯å¦é˜»æ­¢äº†è¿æ¥';
			} else if (error.message.includes('timeout')) {
				errorMessage = 'è·å–ç»“æœè¶…æ—¶';
				errorDetails = 'è·å–æ¯”å¯¹ç»“æœè¶…æ—¶ã€‚è¯·æ£€æŸ¥ï¼š\n' +
					'1. ç½‘ç»œè¿æ¥æ˜¯å¦ç¨³å®š\n' +
					'2. API æœåŠ¡æ˜¯å¦å“åº”æ­£å¸¸\n' +
					'3. æ¯”å¯¹ä»»åŠ¡æ˜¯å¦ä»åœ¨è¿è¡Œä¸­';
			} else if (error.message.includes('404') || error.message.includes('not found')) {
				errorMessage = 'æ¯”å¯¹ç»“æœä¸å­˜åœ¨';
				errorDetails = `æ¯”å¯¹ID "${comparisonId}" å¯¹åº”çš„ç»“æœä¸å­˜åœ¨ã€‚å¯èƒ½çš„åŸå› ï¼š\n` +
					'1. æ¯”å¯¹ä»»åŠ¡ä»åœ¨è¿è¡Œä¸­ï¼Œè¯·ç¨åé‡è¯•\n' +
					'2. æ¯”å¯¹ID ä¸æ­£ç¡®\n' +
					'3. æ¯”å¯¹ä»»åŠ¡å·²è¿‡æœŸæˆ–è¢«æ¸…ç†\n' +
					'4. æ¯”å¯¹ä»»åŠ¡æ‰§è¡Œå¤±è´¥';
			} else if (error.response) {
				const statusCode = error.response.statusCode || 'unknown';
				const statusMessage = error.response.statusMessage || 'unknown';
				
				errorMessage = `HTTPé”™è¯¯ ${statusCode}`;
				errorDetails = `API è¿”å›é”™è¯¯çŠ¶æ€ï¼š${statusCode} ${statusMessage}`;
				
				if (error.response.body) {
					try {
						const body = typeof error.response.body === 'string' ? 
							JSON.parse(error.response.body) : error.response.body;
						if (body.error) {
							errorDetails += `\né”™è¯¯è¯¦æƒ…ï¼š${body.error}`;
						}
					} catch (parseError) {
						errorDetails += `\nå“åº”å†…å®¹ï¼š${error.response.body}`;
					}
				}
			}
			
			// æ„å»ºå‹å¥½çš„é”™è¯¯æ¶ˆæ¯
			const friendlyError = errorDetails ? 
				`${errorMessage}\n\n${errorDetails}` : 
				`${errorMessage}: ${error.message}`;
			
			throw new Error(friendlyError);
		}
	}

	private static extractUpstreamData(items: INodeExecutionData[], autoFill: boolean): any {
		// å§‹ç»ˆè¿”å›ä¸€ä¸ªå¸¦æœ‰é»˜è®¤ç»“æ„çš„å¯¹è±¡ï¼Œé¿å… undefined é”™è¯¯
		const upstreamData: any = {
			connections: [],
			tables: [],
			isMergedData: false, // æ ‡è®°æ˜¯å¦æ¥è‡ª Merge èŠ‚ç‚¹
			sourceInfo: {}, // è®°å½•æ•°æ®æ¥æºä¿¡æ¯
		};

		console.log('=== extractUpstreamData å¼€å§‹ ===');
		console.log('autoFill:', autoFill);
		console.log('itemsæ•°é‡:', items.length);
		console.log('åŸå§‹itemsæ•°æ®:', JSON.stringify(items, null, 2));

		if (!autoFill || items.length === 0) {
			console.log('autoFillä¸ºfalseæˆ–æ²¡æœ‰è¾“å…¥æ•°æ®ï¼Œè¿”å›ç©ºç»“æ„');
			return upstreamData;
		}

		// æ£€æµ‹æ˜¯å¦æ¥è‡ª Merge èŠ‚ç‚¹ï¼ˆå¤šä¸ªitemsä¸”ç»“æ„ç›¸ä¼¼ï¼‰
		if (items.length > 1) {
			const hasConnectionFields = items.every(item => {
				if (!item.json) return false;
				const connectionFields = ['connectionUrl', 'connectionString', 'connection', 'url'];
				return connectionFields.some(field => item.json[field]);
			});

			if (hasConnectionFields) {
				upstreamData.isMergedData = true;
				console.log('âš ï¸ æ£€æµ‹åˆ°æ¥è‡ª Merge èŠ‚ç‚¹çš„æ•°æ®ï¼ŒåŒ…å«å¤šä¸ªè¿æ¥');
				upstreamData.sourceInfo.mergeDetected = true;
				upstreamData.sourceInfo.mergeItemCount = items.length;
			}
		}

		// ä»ä¸Šæ¸¸èŠ‚ç‚¹æå–è¿æ¥ä¿¡æ¯å’Œè¡¨åˆ—è¡¨
		for (const item of items) {
			if (item.json) {
				console.log('å¤„ç†item.json:', JSON.stringify(item.json, null, 2));

				// æå–è¿æ¥ URL - æ”¯æŒå¤šç§å­—æ®µåå’Œæ ¼å¼
				const connectionFields = [
					'connectionUrl', 'connectionString', 'connection',
					'url', 'database_url', 'db_url', 'conn_str'
				];

				for (const field of connectionFields) {
					if (item.json[field]) {
						console.log(`æ‰¾åˆ°è¿æ¥å­—æ®µ ${field}:`, item.json[field]);

						// æ™ºèƒ½æ£€æµ‹æ•°æ®åº“ç±»å‹ - æ”¯æŒå¤šç§å­—æ®µæ¥æº
						let dbType = item.json.databaseType || item.json.database_type;
						console.log('åˆå§‹dbType:', dbType);

						// å¦‚æœæ²¡æœ‰é¡¶çº§ databaseType å­—æ®µï¼Œå°è¯•ä» connectionConfig ä¸­è·å–
						if (!dbType || dbType === 'undefined') {
							const connectionConfig = item.json.connectionConfig || item.json.config;
							console.log('æ£€æŸ¥connectionConfig:', connectionConfig);

							if (connectionConfig && typeof connectionConfig === 'object' && 'type' in connectionConfig) {
								const configType = (connectionConfig as any).type;
								console.log('ä»connectionConfigè·å¾—type:', configType);

								// ç»Ÿä¸€æ•°æ®åº“ç±»å‹å‘½å
								if (configType === 'clickzetta') {
									dbType = 'clickzetta';
								} else if (configType === 'postgres' || configType === 'postgresql') {
									dbType = 'postgresql';
								} else if (configType === 'mysql') {
									dbType = 'mysql';
								} else if (configType === 'sqlite') {
									dbType = 'sqlite';
								} else {
									dbType = configType;
								}
								console.log('æ˜ å°„åçš„dbType:', dbType);
							}
						}

						// å¦‚æœè¿˜æ˜¯æ²¡æœ‰æ˜ç¡®çš„æ•°æ®åº“ç±»å‹ï¼Œå°è¯•ä»è¿æ¥å­—ç¬¦ä¸²æ¨æ–­
						if (!dbType || dbType === 'undefined') {
							const connectionUrl = item.json[field] as string;
							console.log('ä»è¿æ¥å­—ç¬¦ä¸²æ¨æ–­ç±»å‹:', connectionUrl);

							if (connectionUrl.startsWith('postgresql://')) {
								dbType = 'postgresql';
							} else if (connectionUrl.startsWith('clickzetta://')) {
								dbType = 'clickzetta';
							} else if (connectionUrl.startsWith('mysql://')) {
								dbType = 'mysql';
							} else if (connectionUrl.startsWith('sqlite://')) {
								dbType = 'sqlite';
							} else {
								dbType = 'unknown';
							}
							console.log('æ¨æ–­å¾—åˆ°çš„dbType:', dbType);
						}

						// ç»Ÿä¸€ postgres ä¸º postgresql
						if (dbType === 'postgres') {
							dbType = 'postgresql';
						}

						const connectionData = {
							url: item.json[field],
							type: dbType,
							databaseType: dbType, // æ·»åŠ æ ‡å‡†çš„ databaseType å­—æ®µ
							config: item.json.connectionConfig || item.json.config,
							source: field, // è®°å½•æ¥æºå­—æ®µå
						};

						console.log('æ·»åŠ è¿æ¥æ•°æ®:', connectionData);
						upstreamData.connections.push(connectionData);
					}
				}

				// ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯ ClickZetta è¿æ¥å™¨çš„æ ¼å¼
				if (item.json.instance && item.json.username && item.json.password) {
					// æ„å»º ClickZetta è¿æ¥å­—ç¬¦ä¸²
					const clickzettaUrl = `clickzetta://${item.json.username}:${item.json.password}@${item.json.instance}.${item.json.service || 'uat-api.clickzetta.com'}/${item.json.database || 'default'}?virtualcluster=${item.json.virtualcluster || 'default_ap'}&schema=${item.json.schema || 'public'}`;
					upstreamData.connections.push({
						url: clickzettaUrl,
						type: 'clickzetta',
						config: item.json,
						source: 'clickzetta_config',
					});
				}

				// ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯ PostgreSQL è¿æ¥å™¨çš„æ ¼å¼
				if (item.json.host && item.json.database && item.json.username && item.json.password) {
					// æ„å»º PostgreSQL è¿æ¥å­—ç¬¦ä¸²
					const pgUrl = `postgresql://${item.json.username}:${item.json.password}@${item.json.host}:${item.json.port || 5432}/${item.json.database}`;
					upstreamData.connections.push({
						url: pgUrl,
						type: 'postgresql',
						config: item.json,
						source: 'postgresql_config',
					});
				}

				// æå–è¡¨åˆ—è¡¨ - æ”¯æŒå¤šç§æ ¼å¼
				if (item.json.tables && Array.isArray(item.json.tables)) {
					const processedTables = item.json.tables.map((table: any) => {
						if (typeof table === 'string') {
							return {
								name: table,
								value: table,
								description: `Table: ${table}`
							};
						} else if (table && typeof table === 'object') {
							// å®‰å…¨åœ°å¤„ç†å¯¹è±¡æ ¼å¼
							const tableName = table.name || table.value || table.table_name;
							if (tableName && typeof tableName === 'string') {
								return {
									name: tableName,
									value: table.value || tableName,
									description: table.description || `Table: ${tableName}`
								};
							} else {
								// å¦‚æœæ— æ³•æå–æœ‰æ•ˆçš„è¡¨åï¼Œè·³è¿‡è¿™ä¸ªæ¡ç›®
								console.warn('æ— æ³•æå–æœ‰æ•ˆçš„è¡¨å:', table);
								return null;
							}
						}
						return table;
					}).filter(table => table !== null); // è¿‡æ»¤æ‰æ— æ•ˆçš„è¡¨

					upstreamData.tables = upstreamData.tables.concat(processedTables);
				}

				// æ”¯æŒ data å­—æ®µä¸­çš„è¡¨åˆ—è¡¨ï¼ˆæŸäº›èŠ‚ç‚¹ä½¿ç”¨è¿™ç§æ ¼å¼ï¼‰
				if (item.json.data && Array.isArray(item.json.data)) {
					// æ£€æŸ¥æ˜¯å¦æ˜¯è¡¨åæ•°ç»„
					const dataAsTableList = item.json.data.map((dataItem: any) => {
						if (typeof dataItem === 'string') {
							// ç®€å•å­—ç¬¦ä¸²æ ¼å¼
							return {
								name: dataItem,
								value: dataItem,
								description: `Table: ${dataItem}`
							};
						} else if (dataItem && typeof dataItem === 'object') {
							// å¯¹è±¡æ ¼å¼ï¼Œç¡®ä¿æœ‰æ ‡å‡†å­—æ®µ
							const tableName = dataItem.name || dataItem.value || dataItem.table_name;
							if (tableName && typeof tableName === 'string') {
								return {
									name: tableName,
									value: dataItem.value || tableName,
									description: dataItem.description || `Table: ${tableName}`
								};
							} else {
								// å¦‚æœæ— æ³•æå–æœ‰æ•ˆçš„è¡¨åï¼Œè·³è¿‡è¿™ä¸ªæ¡ç›®
								console.warn('æ— æ³•ä» data å­—æ®µæå–æœ‰æ•ˆçš„è¡¨å:', dataItem);
								return null;
							}
						}
						return dataItem;
					}).filter(table => table !== null); // è¿‡æ»¤æ‰æ— æ•ˆçš„è¡¨

					upstreamData.tables = upstreamData.tables.concat(dataAsTableList);
				}
			}
		}

		// è°ƒè¯•è¾“å‡º
		console.log('æå–çš„ä¸Šæ¸¸æ•°æ®:', {
			connectionsCount: upstreamData.connections.length,
			tablesCount: upstreamData.tables.length,
			isMergedData: upstreamData.isMergedData,
			sourceInfo: upstreamData.sourceInfo,
			connections: upstreamData.connections.map(c => ({
				url: c.url.substring(0, 30) + '...',
				type: c.type,
				databaseType: c.databaseType,
				source: c.source
			})),
			tables: upstreamData.tables.slice(0, 5), // åªæ˜¾ç¤ºå‰5ä¸ªè¡¨ä»¥é¿å…æ—¥å¿—è¿‡é•¿
			// æ·»åŠ åŸå§‹æ•°æ®çš„è°ƒè¯•ä¿¡æ¯
			inputDataSample: items.slice(0, 2).map(item => ({
				availableFields: Object.keys(item.json || {}),
				connectionFields: Object.keys(item.json || {}).filter(key =>
					key.toLowerCase().includes('connection') ||
					key.toLowerCase().includes('url')
				),
				databaseType: item.json?.databaseType,
				connectionConfigType: (item.json?.connectionConfig as any)?.type
			})),
			// æ·»åŠ  Merge èŠ‚ç‚¹å¤„ç†å»ºè®®
			mergeNodeAdvice: upstreamData.isMergedData ? 
				'âš ï¸ æ£€æµ‹åˆ°æ¥è‡ª Merge èŠ‚ç‚¹çš„æ•°æ®ã€‚å»ºè®®ä½¿ç”¨è¡¨è¾¾å¼ {{ $("NodeName").item.json.connectionUrl }} è€Œä¸æ˜¯ item 0/1' : 
				'âœ… ç›´æ¥æ¥è‡ª Connector èŠ‚ç‚¹çš„æ•°æ®'
		});

		return upstreamData;
	}

	/**
	 * æµ‹è¯•æ•°æ®åº“è¿æ¥
	 */
	private static async testDatabaseConnection(context: IExecuteFunctions, connectionConfig: any): Promise<{success: boolean, error?: string}> {
		try {
			const testUrl = 'http://data-diff-api:8000/api/v1/test/connection';
			const response = await context.helpers.httpRequest({
				method: 'POST',
				url: testUrl,
				headers: {
					'Content-Type': 'application/json',
				},
				body: { connection_config: connectionConfig },
				json: true,
				returnFullResponse: true,
				timeout: 10000, // 10ç§’è¶…æ—¶
			});

			return {
				success: response.statusCode === 200,
				error: response.statusCode !== 200 ? `HTTP ${response.statusCode}: ${response.body?.error || response.statusMessage}` : undefined
			};
		} catch (error: any) {
			return {
				success: false,
				error: error.message
			};
		}
	}

	/**
	 * å¸¦é‡è¯•æœºåˆ¶çš„APIè°ƒç”¨
	 */
	private static async apiCallWithRetry(
		context: IExecuteFunctions,
		method: string,
		endpoint: string,
		data: any,
		maxRetries: number = 3,
		delayMs: number = 2000
	): Promise<any> {
		let lastError: any;
		
		for (let attempt = 1; attempt <= maxRetries; attempt++) {
			try {
				context.logger.info(`APIè°ƒç”¨å°è¯• ${attempt}/${maxRetries}: ${method} ${endpoint}`);
				
				const baseUrl = 'http://data-diff-api:8000/api/v1';
				const fullUrl = `${baseUrl}${endpoint}`;
				
				const response = await context.helpers.httpRequest({
					method: method as any,
					url: fullUrl,
					headers: {
						'Content-Type': 'application/json',
					},
					body: data,
					json: true,
					returnFullResponse: true,
					timeout: 300000, // 5åˆ†é’Ÿè¶…æ—¶
				});

				// æ£€æŸ¥HTTPçŠ¶æ€ç 
				if (response.statusCode === 404) {
					throw new Error(`èµ„æºæœªæ‰¾åˆ°: ${endpoint}`);
				}

				if (response.statusCode !== 200) {
					throw new Error(`HTTPé”™è¯¯: ${response.statusCode} ${response.statusMessage}`);
				}

				// æˆåŠŸè¿”å›ç»“æœ
				if (attempt > 1) {
					context.logger.info(`APIè°ƒç”¨åœ¨ç¬¬${attempt}æ¬¡å°è¯•åæˆåŠŸ`);
				}
				return response.body;
				
			} catch (error: any) {
				lastError = error;
				
				// æ£€æŸ¥æ˜¯å¦æ˜¯è¿æ¥ç›¸å…³é”™è¯¯
				const isConnectionError = 
					error.message.includes('connection already closed') ||
					error.message.includes('connection timeout') ||
					error.message.includes('connection refused') ||
					error.message.includes('ECONNRESET') ||
					error.message.includes('ECONNREFUSED') ||
					error.message.includes('ETIMEDOUT') ||
					error.message.includes('InterfaceError') ||
					error.message.includes('OperationalError') ||
					error.cause?.code === 'ECONNRESET' ||
					error.cause?.code === 'ECONNREFUSED' ||
					error.cause?.code === 'ETIMEDOUT';
				
				if (isConnectionError && attempt < maxRetries) {
					context.logger.warn(`è¿æ¥é”™è¯¯ï¼Œ${delayMs}msåé‡è¯• (å°è¯• ${attempt}/${maxRetries}): ${error.message}`);
					await DataComparison.sleep(delayMs);
					
					// æŒ‡æ•°é€€é¿ç­–ç•¥
					delayMs = Math.min(delayMs * 1.5, 10000);
					continue;
				}
				
				// å¦‚æœæ˜¯HTTP 404é”™è¯¯ï¼Œç›´æ¥æŠ›å‡ºï¼Œä¸é‡è¯•
				if (error.message.includes('èµ„æºæœªæ‰¾åˆ°') || error.message.includes('404')) {
					throw error;
				}
				
				// å¦‚æœä¸æ˜¯è¿æ¥é”™è¯¯æˆ–å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼ŒæŠ›å‡ºå¼‚å¸¸
				if (attempt === maxRetries) {
					context.logger.error(`APIè°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°: ${error.message}`);
					throw error;
				}
				
				// å…¶ä»–é”™è¯¯ä¹Ÿé‡è¯•ä¸€æ¬¡
				context.logger.warn(`APIè°ƒç”¨å¤±è´¥ï¼Œé‡è¯• (å°è¯• ${attempt}/${maxRetries}): ${error.message}`);
				await DataComparison.sleep(delayMs);
			}
		}
		
		throw lastError;
	}

	/**
	 * å¸¦é‡è¯•æœºåˆ¶çš„ API è°ƒç”¨åŒ…è£…å™¨åˆ¶çš„ API è°ƒç”¨åŒ…è£…å™¨
	 * ä¸“é—¨å¤„ç†æ•°æ®åº“è¿æ¥é”™è¯¯å’Œç½‘ç»œé—®é¢˜ä¸“é—¨å¤„ç†æ•°æ®åº“è¿æ¥é”™è¯¯å’Œç½‘ç»œé—®é¢˜
	 */
	private static async executeWithRetry<T>(
		operation: () => Promise<T>,operation: () => Promise<T>,
		context: {		context: {
			operationName: string;
			maxRetries?: number;xRetries?: number;
			baseDelay?: number;r;
			maxDelay?: number;
			retryCondition?: (error: any) => boolean;tryCondition?: (error: any) => boolean;
		}		}
	): Promise<T> {
		const {
			operationName,
			maxRetries = 3,maxRetries = 3,
			baseDelay = 1000,			baseDelay = 1000,
			maxDelay = 10000,
			retryCondition = DataComparison.isRetryableError
		} = context;

		let lastError: any;
		let attempt = 0;

		while (attempt <= maxRetries) {ies) {
			try {
				console.log(`[${operationName}] å°è¯• ${attempt + 1}/${maxRetries + 1}`);1}/${maxRetries + 1}`);
				const result = await operation();t operation();
				
				if (attempt > 0) {	if (attempt > 0) {
					console.log(`[${operationName}] é‡è¯•æˆåŠŸï¼Œæ€»å…±å°è¯•äº† ${attempt + 1} æ¬¡`);					console.log(`[${operationName}] é‡è¯•æˆåŠŸï¼Œæ€»å…±å°è¯•äº† ${attempt + 1} æ¬¡`);
				}
				
				return result;
			} catch (error: any) {
				lastError = error;				lastError = error;
				console.error(`[${operationName}] å°è¯• ${attempt + 1} å¤±è´¥:`, error.message);}] å°è¯• ${attempt + 1} å¤±è´¥:`, error.message);

				// å¦‚æœæ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œæˆ–è€…é”™è¯¯ä¸å¯é‡è¯•ï¼Œç›´æ¥æŠ›å‡ºè¯¯ä¸å¯é‡è¯•ï¼Œç›´æ¥æŠ›å‡º
				if (attempt >= maxRetries || !retryCondition(error)) {				if (attempt >= maxRetries || !retryCondition(error)) {
					console.error(`[${operationName}] ä¸å†é‡è¯•ï¼ŒåŸå› : ${attempt >= maxRetries ? 'è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°' : 'é”™è¯¯ä¸å¯é‡è¯•'}`);}] ä¸å†é‡è¯•ï¼ŒåŸå› : ${attempt >= maxRetries ? 'è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°' : 'é”™è¯¯ä¸å¯é‡è¯•'}`);
					throw error;
				}

				// è®¡ç®—å»¶è¿Ÿæ—¶é—´ (æŒ‡æ•°é€€é¿ + éšæœºæŠ–åŠ¨)
				const delay = Math.min(elay = Math.min(
					baseDelay * Math.pow(2, attempt) + Math.random() * 1000,attempt) + Math.random() * 1000,
					maxDelay
				);

				console.log(`[${operationName}] ${delay}ms åé‡è¯•...`);				console.log(`[${operationName}] ${delay}ms åé‡è¯•...`);
				await DataComparison.sleep(delay);ataComparison.sleep(delay);
				attempt++;
			}
		}

		throw lastError;
	}

	/**
	 * åˆ¤æ–­é”™è¯¯æ˜¯å¦å¯ä»¥é‡è¯•æ–­é”™è¯¯æ˜¯å¦å¯ä»¥é‡è¯•
	 *//
	private static isRetryableError(error: any): boolean {	private static isRetryableError(error: any): boolean {
		const errorMessage = error.message?.toLowerCase() || '';error.message?.toLowerCase() || '';
		
		// å¯é‡è¯•çš„é”™è¯¯ç±»å‹
		const retryablePatterns = [		const retryablePatterns = [
			'connection already closed',',
			'connection reset',
			'connection refused',
			'connection timeout',
			'connection lost',
			'timeout',
			'network error',etwork error',
			'econnrefused',			'temporary failure',
			'etimedout',lable',
			'socket hang up',
			'socket timeout',
			'read timeout',
			'write timeout',enotfound',
			'connection pool exhausted',			'socket hang up',
			'max connections reached',t',
			'server temporarily unavailable'meout',
		];

		// ä¸å¯é‡è¯•çš„é”™è¯¯ç±»å‹'max connections reached',
		const nonRetryablePatterns = [	'server temporarily unavailable'
			'authentication failed',		];
			'invalid credentials',
			'permission denied',é‡è¯•çš„é”™è¯¯ç±»å‹
			'access denied',
			'not found',
			'table does not exist',			'invalid credentials',
			'database does not exist',ed',
			'invalid query',
			'syntax error',not found',
			'column does not exist',			'table does not exist',
			'invalid configuration',
			'malformed request'			'invalid query',
		];ax error',

		// æ£€æŸ¥æ˜¯å¦æ˜¯ä¸å¯é‡è¯•çš„é”™è¯¯			'invalid configuration',
		for (const pattern of nonRetryablePatterns) {med request'
			if (errorMessage.includes(pattern)) {
				return false;
			}		// æ£€æŸ¥æ˜¯å¦æ˜¯ä¸å¯é‡è¯•çš„é”™è¯¯
		}atterns) {

		// æ£€æŸ¥æ˜¯å¦æ˜¯å¯é‡è¯•çš„é”™è¯¯return false;
		for (const pattern of retryablePatterns) {			}
			if (errorMessage.includes(pattern)) {
				return true;
			} æ£€æŸ¥æ˜¯å¦æ˜¯å¯é‡è¯•çš„é”™è¯¯
		}		for (const pattern of retryablePatterns) {
orMessage.includes(pattern)) {
		// HTTP çŠ¶æ€ç æ£€æŸ¥
		if (error.response) {
			const statusCode = error.response.statusCode;
			// 5xx é”™è¯¯å’ŒæŸäº› 4xx é”™è¯¯å¯ä»¥é‡è¯•
			return statusCode >= 500 || statusCode === 408 || statusCode === 429; HTTP çŠ¶æ€ç æ£€æŸ¥
		}		if (error.response) {
tatusCode = error.response.statusCode;
		// é»˜è®¤ä¸é‡è¯•æœªçŸ¥é”™è¯¯
		return false;atusCode === 429;
	}

	/** é»˜è®¤ä¸é‡è¯•æœªçŸ¥é”™è¯¯
	 * ç¡çœ å‡½æ•°		return false;
	 */
	private static sleep(ms: number): Promise<void> {
		return new Promise(resolve => setTimeout(resolve, ms));
	}
/
	private static parseConnectionString(connectionString: string): any {rivate static sleep(ms: number): Promise<void> {
		/**		return new Promise(resolve => setTimeout(resolve, ms));
		 * è§£ææ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²ä¸ºé…ç½®å¯¹è±¡
		 * æ”¯æŒ PostgreSQL å’Œ ClickZetta æ ¼å¼
		 */

		// å¦‚æœä¼ å…¥çš„å·²ç»æ˜¯å¯¹è±¡ï¼ˆå¯èƒ½æ˜¯ä»ä¸Šæ¸¸èŠ‚ç‚¹ä¼ é€’è¿‡æ¥çš„ï¼‰
		if (typeof connectionString === 'object') {ic async httpRequestWithRetry(
			return connectionString;
		}

		// PostgreSQL: postgresql://user:pass@host:port/databasePromise<any> {
		if (connectionString.startsWith('postgresql://')) {turn DataComparison.executeWithRetry(
			const url = new URL(connectionString);			async () => {
			return {le.log(`[${operationName}] å‘é€ HTTP è¯·æ±‚åˆ°:`, requestOptions.url);
				database_type: 'postgresql',tOptions);
				host: url.hostname,
				port: parseInt(url.port) || 5432,				// æ£€æŸ¥å“åº”æ˜¯å¦åŒ…å«åº”ç”¨çº§é”™è¯¯
				username: url.username,
				password: url.password,.error}`);
				database: url.pathname.substring(1), // ç§»é™¤å¼€å¤´çš„ /	}
				db_schema: 'public'				
			};
		}

		// ClickZetta: clickzetta://user:pass@host/database?virtualcluster=xxx&schema=xxx: `HTTP-${operationName}`,
		if (connectionString.startsWith('clickzetta://')) {
			const url = new URL(connectionString);,
			const params = new URLSearchParams(url.search);

			// ä»ä¸»æœºåä¸­æå– instance å’Œ service ä¿¡æ¯
			let instance = '';	}
			let service = '';

			if (url.hostname.includes('.')) {
				// æ ¼å¼å¦‚ instance.service.com
				const hostParts = url.hostname.split('.');thCheck(
				instance = hostParts[0];nctions,
				service = hostParts.slice(1).join('.');
			} else {ationName: string
				// å¦‚æœæ²¡æœ‰ç‚¹åˆ†éš”ï¼Œå‡è®¾æ•´ä¸ªæ˜¯ instanceromise<{healthy: boolean, latency?: number, error?: string}> {
				instance = url.hostname;		const startTime = Date.now();
				service = 'uat-api.clickzetta.com'; // é»˜è®¤æœåŠ¡åœ°å€
			}

			return {uestWithRetry(
				database_type: 'clickzetta',				context,
				username: url.username,
				password: url.password,
				instance: instance,					url: testUrl,
				service: service,on' },
				workspace: url.pathname.substring(1) || 'default', // ç§»é™¤å¼€å¤´çš„ /Config },
				db_schema: params.get('schema') || 'public', // ä¿®æ”¹ä¸º db_schema ä»¥åŒ¹é… API æœŸæœ›
				vcluster: params.get('virtualcluster') || 'default_ap' // é»˜è®¤è™šæ‹Ÿé›†ç¾¤ponse: true,
			};
		}
${operationName}`
		// å¦‚æœæ˜¯å…¶ä»–æ ¼å¼ï¼Œå°è¯•ä½œä¸ºJSONè§£æ
		try {
			const parsed = JSON.parse(connectionString);st latency = Date.now() - startTime;
			const healthy = response.statusCode === 200;
			// ç¡®ä¿ Clickzetta å¯¹è±¡æœ‰æ­£ç¡®çš„å­—æ®µå
			if (parsed.database_type === 'clickzetta') { ${healthy ? 'âœ… å¥åº·' : 'âŒ å¼‚å¸¸'}, å»¶è¿Ÿ: ${latency}ms`);
				// å¦‚æœä½¿ç”¨ schemaï¼Œè½¬æ¢ä¸º db_schema
				if (parsed.schema && !parsed.db_schema) {
					parsed.db_schema = parsed.schema;
					delete parsed.schema; // åˆ é™¤åŸæ¥çš„ schema å­—æ®µï¼Œé¿å…æ··æ·†
				}ndefined : `HTTP ${response.statusCode}: ${response.body?.error || response.statusMessage}`

				// ç¡®ä¿å¿…è¦å­—æ®µæœ‰é»˜è®¤å€¼ch (error: any) {
				parsed.service = parsed.service || 'uat-api.clickzetta.com';st latency = Date.now() - startTime;
				parsed.vcluster = parsed.vcluster || 'default_ap';nsole.error(`[${operationName}] è¿æ¥å¥åº·æ£€æŸ¥å¤±è´¥:`, error.message);
				parsed.db_schema = parsed.db_schema || 'public';			
			} {

			return parsed;
		} catch {
			// å¦‚æœè§£æå¤±è´¥ï¼Œè¿”å›åŸå§‹å­—ç¬¦ä¸²ï¼ˆå‘åå…¼å®¹ï¼‰			};
			throw new Error(`Unsupported connection string format: ${connectionString}`);
		}
	}

	private static generateSchemaSummary(summary: any, diff: any): string {å’Œæµ‹è¯•è¿æ¥
		try {
			const identical = summary?.schemas_identical || false;ns(
			const totalDiffs = summary?.total_differences || 0;

			if (identical) {
				return "âœ… æ¨¡å¼å®Œå…¨ç›¸åŒ - ä¸¤ä¸ªæ•°æ®åº“çš„æ¨¡å¼ç»“æ„ä¸€è‡´";
			}ise<{success: boolean, sourceHealth?: any, targetHealth?: any, error?: string}> {
le.log(`[${operationName}] å¼€å§‹è¿æ¥é¢„çƒ­...`);
			const parts: string[] = [];
 {
			// æ€»è§ˆ			// å¹¶è¡Œæ£€æŸ¥ä¸¤ä¸ªè¿æ¥çš„å¥åº·çŠ¶å†µ
			parts.push(`ğŸ“Š å‘ç° ${totalDiffs} ä¸ªå·®å¼‚`);alth, targetHealth] = await Promise.all([
		DataComparison.performConnectionHealthCheck(context, sourceConfig, `${operationName}-Source`),
			// è¡¨çº§å·®å¼‚				DataComparison.performConnectionHealthCheck(context, targetConfig, `${operationName}-Target`)
			const tablesOnlySource = diff?.tables_only_in_source || [];);
			const tablesOnlyTarget = diff?.tables_only_in_target || [];
ess = sourceHealth.healthy && targetHealth.healthy;
			if (tablesOnlySource.length > 0) {
				parts.push(`ğŸ“¤ ä»…åœ¨æºæ•°æ®åº“: ${tablesOnlySource.join(', ')}`);
			}nName}] è¿æ¥é¢„çƒ­æˆåŠŸ - æºå»¶è¿Ÿ: ${sourceHealth.latency}ms, ç›®æ ‡å»¶è¿Ÿ: ${targetHealth.latency}ms`);
			} else {
			if (tablesOnlyTarget.length > 0) {æ¥é¢„çƒ­å‘ç°é—®é¢˜:`, {
				parts.push(`ğŸ“¥ ä»…åœ¨ç›®æ ‡æ•°æ®åº“: ${tablesOnlyTarget.join(', ')}`);ealth.healthy ? 'âœ…' : `âŒ ${sourceHealth.error}`,
			}		target: targetHealth.healthy ? 'âœ…' : `âŒ ${targetHealth.error}`
				});
			// åˆ—çº§å·®å¼‚
			const columnDiffs = diff?.column_diffs || {};
			const columnDiffCount = Object.keys(columnDiffs).length;
			if (columnDiffCount > 0) {	success,
				parts.push(`ğŸ“‹ ${columnDiffCount} ä¸ªè¡¨æœ‰åˆ—å·®å¼‚`);				sourceHealth,
			}alth,
		error: success ? undefined : `è¿æ¥é¢„çƒ­å¤±è´¥: ${!sourceHealth.healthy ? `æºè¿æ¥: ${sourceHealth.error}` : ''}${!targetHealth.healthy ? ` ç›®æ ‡è¿æ¥: ${targetHealth.error}` : ''}`
			// ç±»å‹å·®å¼‚			};
			const typeDiffs = diff?.type_diffs || {};	} catch (error: any) {
			const typeDiffCount = Object.keys(typeDiffs).length;			console.error(`[${operationName}] è¿æ¥é¢„çƒ­å¼‚å¸¸:`, error.message);































































































































}	}		return '';		}			return tableData.value || tableData.name || tableData.table_name || '';			// å°è¯•ä¸åŒçš„å­—æ®µå		if (typeof tableData === 'object') {		}			return tableData;		if (typeof tableData === 'string') {		if (!tableData) return '';	private static safeExtractTableName(tableData: any): string {	 */	 * æ”¯æŒå¤šç§è¡¨æ•°æ®æ ¼å¼	 * å®‰å…¨åœ°ä»ä¸Šæ¸¸æ•°æ®æå–è¡¨å	/**	}		return detailed;		});			}				});					});						recommendation: 'æ£€æŸ¥æ•°æ®å…¼å®¹æ€§å¹¶è€ƒè™‘ç±»å‹è½¬æ¢'						impact: 'high',						description: `è¡¨ "${table}" ä¸­åˆ— "${change.column}" çš„ç±»å‹ä¸åŒ¹é…: ${change.source_type} vs ${change.target_type}`,						targetType: change.target_type,						sourceType: change.source_type,						column: change.column,						table: table,						type: 'type_mismatch',					detailed.typeLevelDifferences.push({				changes.forEach((change: any) => {			if (Array.isArray(changes)) {			detailed.summary.hasTypeDifferences = true;		Object.entries(typeDiffs).forEach(([table, changes]: [string, any]) => {		const typeDiffs = diff?.type_diffs || {};		// ç±»å‹å·®å¼‚		});			});				});					recommendation: 'æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ é™¤æ­¤åˆ—æˆ–åœ¨æºæ•°æ®åº“ä¸­æ·»åŠ '					impact: 'medium',					description: `è¡¨ "${table}" ä¸­çš„åˆ— "${column}" ä»…å­˜åœ¨äºç›®æ ‡æ•°æ®åº“`,					column: column,					table: table,					type: 'column_missing_in_source',				detailed.columnLevelDifferences.push({			colsOnlyTarget.forEach((column: string) => {			});				});					recommendation: 'åœ¨ç›®æ ‡æ•°æ®åº“çš„æ­¤è¡¨ä¸­æ·»åŠ è¯¥åˆ—'					impact: 'high',					description: `è¡¨ "${table}" ä¸­çš„åˆ— "${column}" ä»…å­˜åœ¨äºæºæ•°æ®åº“`,					column: column,					table: table,					type: 'column_missing_in_target',				detailed.columnLevelDifferences.push({			colsOnlySource.forEach((column: string) => {			const colsOnlyTarget = diffs.columns_only_in_target || [];			const colsOnlySource = diffs.columns_only_in_source || [];			detailed.summary.hasColumnDifferences = true;		Object.entries(columnDiffs).forEach(([table, diffs]: [string, any]) => {		const columnDiffs = diff?.column_diffs || {};		// åˆ—çº§å·®å¼‚		});			});				recommendation: 'æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ é™¤æ­¤è¡¨æˆ–åœ¨æºæ•°æ®åº“ä¸­æ·»åŠ '				impact: 'medium',				description: `è¡¨ "${table}" ä»…å­˜åœ¨äºç›®æ ‡æ•°æ®åº“ä¸­`,				table: table,				type: 'missing_in_source',			detailed.tableLevelDifferences.push({		tablesOnlyTarget.forEach((table: string) => {		});			});				recommendation: 'åœ¨ç›®æ ‡æ•°æ®åº“ä¸­åˆ›å»ºæ­¤è¡¨'				impact: 'high',				description: `è¡¨ "${table}" ä»…å­˜åœ¨äºæºæ•°æ®åº“ä¸­`,				table: table,				type: 'missing_in_target',			detailed.tableLevelDifferences.push({		tablesOnlySource.forEach((table: string) => {		}			detailed.summary.hasTableDifferences = true;		if (tablesOnlySource.length > 0 || tablesOnlyTarget.length > 0) {		const tablesOnlyTarget = diff?.tables_only_in_target || [];		const tablesOnlySource = diff?.tables_only_in_source || [];		// è¡¨çº§å·®å¼‚		};			}				hasTypeDifferences: false				hasColumnDifferences: false,				hasTableDifferences: false,			summary: {			typeLevelDifferences: [],			columnLevelDifferences: [],			tableLevelDifferences: [],		const detailed: any = {	private static generateDetailedDifferences(diff: any): any {	}		}			return "âš ï¸ æ¨¡å¼æ¯”å¯¹å®Œæˆä½†æ‘˜è¦ç”Ÿæˆå¤±è´¥";		} catch (error) {			return parts.join(' | ');			}				parts.push(`ğŸ”„ ${typeDiffCount} ä¸ªè¡¨æœ‰ç±»å‹å·®å¼‚`);			if (typeDiffCount > 0) {			return {
				success: false,
				error: `è¿æ¥é¢„çƒ­å¼‚å¸¸: ${error.message}`
			};
		}
	}

	private static async compareTables(context: IExecuteFunctions, itemIndex: number, upstreamData: any): Promise<any> {
		let sourceConnection = context.getNodeParameter('sourceConnection', itemIndex) as string;
		let targetConnection = context.getNodeParameter('targetConnection', itemIndex) as string;
		let sourceTable = context.getNodeParameter('sourceTable', itemIndex) as string;
		let targetTable = context.getNodeParameter('targetTable', itemIndex) as string;
		const keyColumns = context.getNodeParameter('keyColumns', itemIndex) as string;
		const columnsToCompare = context.getNodeParameter('columnsToCompare', itemIndex) as string;
		const whereCondition = context.getNodeParameter('whereCondition', itemIndex) as string;

		// è·å–å‡­è¯
		const credentials = await context.getCredentials('dataDiffConfig');

		// è·å–æ‰€æœ‰è¾“å…¥é¡¹ä»¥ä¾¿å¤„ç† item 0/1 çš„æƒ…å†µ
		const allItems = context.getInputData();

		// æ£€æŸ¥è¿æ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºç©ºæˆ– undefinedï¼Œä½¿ç”¨å‡­è¯ä¸­çš„é»˜è®¤å€¼
		if (!sourceConnection || sourceConnection === 'undefined') {
			sourceConnection = (credentials?.defaultSourceConnection as string) || '';
			console.log('ä½¿ç”¨å‡­è¯ä¸­çš„é»˜è®¤æºè¿æ¥');
		}
		if (!targetConnection || targetConnection === 'undefined') {
			targetConnection = (credentials?.defaultTargetConnection as string) || '';
			console.log('ä½¿ç”¨å‡­è¯ä¸­çš„é»˜è®¤ç›®æ ‡è¿æ¥');
		}

		// å¦‚æœè¡¨åä¸ºç©ºï¼Œå°è¯•ä»ä¸Šæ¸¸æ•°æ®è·å–
		if (!sourceTable && upstreamData.tables && upstreamData.tables.length > 0) {
			// é€‰æ‹©ç¬¬ä¸€ä¸ªéç³»ç»Ÿè¡¨
			const filteredTables = upstreamData.tables.filter((table: any) => {
				const name = table?.name || table?.value || table;
				return !name.startsWith('_') && !name.includes('metadata') && !name.includes('system');
			});
			sourceTable = filteredTables.length > 0 ?
				(filteredTables[0].name || filteredTables[0].value || filteredTables[0]) :
				(upstreamData.tables[0].name || upstreamData.tables[0].value || upstreamData.tables[0]);
		}

		if (!targetTable && upstreamData.tables && upstreamData.tables.length > 0) {
			// é€‰æ‹©ç¬¬ä¸€ä¸ªéç³»ç»Ÿè¡¨ï¼Œä½†ä¸æºè¡¨ä¸åŒ
			const filteredTables = upstreamData.tables.filter((table: any) => {
				const name = table?.name || table?.value || table;
				return !name.startsWith('_') && !name.includes('metadata') && !name.includes('system') && name !== sourceTable;
			});
			if (filteredTables.length > 0) {
				targetTable = filteredTables[0].name || filteredTables[0].value || filteredTables[0];
			} else if (upstreamData.tables.length > 1) {
				// å¦‚æœæ²¡æœ‰åˆé€‚çš„è¿‡æ»¤è¡¨ï¼Œé€‰æ‹©ç¬¬äºŒä¸ªè¡¨
				targetTable = upstreamData.tables[1].name || upstreamData.tables[1].value || upstreamData.tables[1];
			} else {
				// å¦‚æœåªæœ‰ä¸€ä¸ªè¡¨ï¼Œä½¿ç”¨ç›¸åŒçš„è¡¨ï¼ˆå¯èƒ½æ˜¯ä¸åŒæ•°æ®åº“çš„åŒåè¡¨ï¼‰
				targetTable = sourceTable;
			}
		}

		console.log('è¿æ¥å’Œè¡¨ä¿¡æ¯:', {
			sourceConnection: sourceConnection ? 'present' : 'missing',
			targetConnection: targetConnection ? 'present' : 'missing',
			sourceTable: sourceTable || 'missing',
			targetTable: targetTable || 'missing',
			availableTables: upstreamData.tables?.length || 0
		});

		if (!sourceConnection) {
			throw new Error('Source connection string is required. Please:\n1. Provide it in the node parameters\n2. Set defaultSourceConnection in credentials\n3. Use drag-and-drop from upstream nodes\n4. Check if your expression (e.g., "{{ $json.connectionUrl }}") returns undefined - verify the upstream node name and field path');
		}
		if (!targetConnection) {
			throw new Error('Target connection string is required. Please:\n1. Provide it in the node parameters\n2. Set defaultTargetConnection in credentials\n3. Use drag-and-drop from upstream nodes\n4. Check if your expression (e.g., "{{ $json.connectionUrl }}") returns undefined - verify the upstream node name and field path');
		}
		if (!sourceTable) {
			throw new Error('Source table name is required');
		}
		if (!targetTable) {
			throw new Error('Target table name is required');
		}

		// å‚æ•°ä¼˜å…ˆçº§ï¼šèŠ‚ç‚¹è¡¨å•å‚æ•° > å‡­æ®é…ç½® > é»˜è®¤å€¼
		const mergedKeyColumns = keyColumns || (typeof credentials?.keyColumns === 'string' ? credentials.keyColumns : '') || 'id';
		const mergedSampleSize = (typeof credentials?.sampleSize === 'number' ? credentials.sampleSize : 0) || 10000;
		const mergedThreads = (typeof credentials?.threads === 'number' ? credentials.threads : 0) || 4;
		const mergedCaseSensitive = credentials?.caseSensitive !== undefined ? credentials.caseSensitive : true;
		const mergedTolerance = (typeof credentials?.tolerance === 'number' ? credentials.tolerance : 0) || 0.001;
		const mergedMethod = (typeof credentials?.method === 'string' ? credentials.method : '') || 'hashdiff';
		const mergedExcludeColumns = (typeof credentials?.excludeColumns === 'string' ? credentials.excludeColumns : '') || '';
		const mergedBisectionThreshold = (typeof credentials?.bisectionThreshold === 'number' ? credentials.bisectionThreshold : 0) || 1024;
		const mergedStrictTypeChecking = credentials?.strictTypeChecking !== undefined ? credentials.strictTypeChecking : false;

		// è°ƒç”¨API
		try {
			const apiUrl = 'http://data-diff-api:8000/api/v1/compare/tables/nested';

			// è§£æåˆ—å - ä½¿ç”¨åˆå¹¶åçš„å‚æ•°ï¼Œç¡®ä¿ç±»å‹å®‰å…¨
			const keyColumnsList = typeof mergedKeyColumns === 'string' && mergedKeyColumns ?
				mergedKeyColumns.split(',').map(col => col.trim()).filter(col => col) :
				['id'];

			const columnsToCompareList = typeof columnsToCompare === 'string' && columnsToCompare ?
				columnsToCompare.split(',').map(col => col.trim()).filter(col => col) :
				[];

			// å¤„ç†æ’é™¤åˆ—ï¼ˆæ¥è‡ªå‡­æ®ï¼‰ï¼Œç¡®ä¿ç±»å‹å®‰å…¨
			const excludeColumnsList = typeof mergedExcludeColumns === 'string' && mergedExcludeColumns ?
				mergedExcludeColumns.split(',').map(col => col.trim()).filter(col => col) :
				[];

			// è§£æè¿æ¥å­—ç¬¦ä¸²ä¸ºé…ç½®å¯¹è±¡
			const sourceConfig = DataComparison.parseConnectionString(sourceConnection);
			const targetConfig = DataComparison.parseConnectionString(targetConnection);

			// ä½¿ç”¨åµŒå¥—çš„ JSON è¯·æ±‚æ–¹å¼ï¼Œä¸ nested ç«¯ç‚¹ä¿æŒä¸€è‡´
			const requestData = {
				source_config: sourceConfig,
				target_config: targetConfig,
				comparison_config: {
					source_table: sourceTable,
					target_table: targetTable,
					key_columns: keyColumnsList,
					columns_to_compare: columnsToCompareList.length > 0 ? columnsToCompareList : undefined,
					exclude_columns: excludeColumnsList.length > 0 ? excludeColumnsList : undefined,
					sample_size: mergedSampleSize,
					threads: mergedThreads,
					case_sensitive: mergedCaseSensitive,
					tolerance: mergedTolerance,
					algorithm: mergedMethod,
					bisection_threshold: mergedBisectionThreshold,
					where_condition: whereCondition || undefined,
					strict_type_checking: mergedStrictTypeChecking
				}
			};

			console.log('å‘é€APIè¯·æ±‚ (çº¯JSONæ–¹å¼)');
			console.log('è¯·æ±‚URL:', apiUrl);
			console.log('è¯·æ±‚ä½“:', JSON.stringify(requestData, null, 2));

			// å‘é€è¯·æ±‚ï¼ˆä½¿ç”¨é‡è¯•æœºåˆ¶ï¼‰
			try {
				const response = await DataComparison.apiCallWithRetry(
					context,
					'POST',
					'/compare/data',
					requestData,
					3,
					2000
				);

				console.log('APIè¯·æ±‚æˆåŠŸï¼Œå“åº”:', JSON.stringify(response));

				// æ£€æŸ¥ API æ˜¯å¦è¿”å›é”™è¯¯
				if (response.error) {
					throw new Error(`APIè¿”å›é”™è¯¯: ${response.error}`);
				}

				// API è¿”å›çš„æ˜¯ comparison_idï¼Œç›´æ¥è¿”å›è€Œä¸ç­‰å¾…ç»“æœ
				const comparisonId = response.comparison_id;
				if (!comparisonId) {
					throw new Error('API æœªè¿”å›æ¯”å¯¹ID');
				}

				return {
					comparisonId: comparisonId,
					status: response.body.status || 'started',
					message: response.body.message || 'è¡¨æ¯”å¯¹ä»»åŠ¡å·²å¯åŠ¨',
					requestData: requestData,
					apiUrl: apiUrl,
					timestamp: new Date().toISOString(),
					retrieveResultUrl: `http://data-diff-api:8000/api/v1/compare/results/${comparisonId}`,
					note: 'Use the "Get Comparison Result" operation with this comparison ID to retrieve the results'
				};
			} catch (error: any) {
				console.error('APIè¯·æ±‚å¤±è´¥:', error.message);
				if (error.response) {
					console.error('é”™è¯¯å“åº”çŠ¶æ€:', error.response.statusCode);
					console.error('é”™è¯¯å“åº”å†…å®¹:', JSON.stringify(error.response.body));
				}
				throw new Error(`å¯åŠ¨è¡¨æ¯”å¯¹å¤±è´¥: ${error.message}`);
			}
		} catch (error: any) {
			throw new Error(`Data comparison API request failed: ${error.message}`);
		}
	}

	private static async compareSchemas(context: IExecuteFunctions, itemIndex: number, upstreamData: any): Promise<any> {
		let sourceConnection = context.getNodeParameter('sourceConnection', itemIndex) as string;
		let targetConnection = context.getNodeParameter('targetConnection', itemIndex) as string;

		// æ™ºèƒ½æ”¶é›†æ‰€æœ‰å¯ç”¨çš„è¿æ¥ä¿¡æ¯
		const allItems = context.getInputData();
		const allConnections: string[] = [];

		// ä»æ‰€æœ‰è¾“å…¥é¡¹ä¸­æ”¶é›†è¿æ¥ä¿¡æ¯
		for (let i = 0; i < allItems.length; i++) {
			const item = allItems[i];
			if (item.json) {
				const connectionFields = ['connectionUrl', 'connectionString', 'connection', 'url'];
				for (const field of connectionFields) {
					if (item.json[field] && typeof item.json[field] === 'string') {
						if (!allConnections.includes(item.json[field])) {
							allConnections.push(item.json[field]);
						}
					}
				}
			}
		}

		// ä»èŠ‚ç‚¹å‚æ•°ä¸­æ”¶é›†è¿æ¥ä¿¡æ¯
		for (let i = 0; i < allItems.length; i++) {
			try {
				const srcConn = context.getNodeParameter('sourceConnection', i, '') as string;
				const tgtConn = context.getNodeParameter('targetConnection', i, '') as string;

				if (srcConn && !allConnections.includes(srcConn)) {
					allConnections.push(srcConn);
				}
				if (tgtConn && !allConnections.includes(tgtConn)) {
					allConnections.push(tgtConn);
				}
			} catch (error) {
				// å¿½ç•¥å‚æ•°è·å–é”™è¯¯ï¼Œç»§ç»­å¤„ç†å…¶ä»–é¡¹
			}
		}

		// ä»ä¸Šæ¸¸æ•°æ®ä¸­æ”¶é›†è¿æ¥ä¿¡æ¯
		if (upstreamData.connections && upstreamData.connections.length > 0) {
			for (const conn of upstreamData.connections) {
				if (conn.url && !allConnections.includes(conn.url)) {
					allConnections.push(conn.url);
				}
			}
		}

		// æ™ºèƒ½åˆ†é…è¿æ¥ä¿¡æ¯
		if (!sourceConnection && allConnections.length > 0) {
			sourceConnection = allConnections[0];
		}
		if (!targetConnection && allConnections.length > 1) {
			targetConnection = allConnections[1];
		} else if (!targetConnection && allConnections.length > 0) {
			targetConnection = allConnections[0];
		}

		console.log('æ¨¡å¼æ¯”è¾ƒæ™ºèƒ½æ”¶é›†ç»“æœ:', {
			itemIndex,
			allConnections: allConnections.map(c => c.substring(0, 20) + '...'),
			sourceConnection: sourceConnection ? 'present' : 'missing',
			targetConnection: targetConnection ? 'present' : 'missing',
			inputItemsCount: allItems.length
		});

		if (!sourceConnection) {
			throw new Error('Source connection string is required');